{"version":3,"names":["MapProp","opts","component","variableName","componentWillLoad","console","error","prefix","attributePrefix","variable","this","attributes","getElement","mapAttributesToProp","Array","from","_a","splitValues","call","ArrayProp","attributeWithBrackets","camelToKebab","value","isArray","valueAsArray","JSON","parse","e","splitAttributeValueOnCommas","attributeValue","splitButIgnoreEscapeSymbolsExpression","valuesWithEscapeSymbols","matchAll","removeEscapeSymbolsExpression","map","replace","mapVariable","attributesToStringMap","Object","assign","stringMapToStringArrayMap","entries","reduce","acc","key","subValue","trim","kebabPrefix","i","length","attribute","name","indexOf","property","kebabToCamel"],"sources":["src/utils/props-utils.ts"],"sourcesContent":["import {isArray} from '@coveo/bueno';\nimport {ComponentInterface, getElement} from '@stencil/core';\nimport {camelToKebab, kebabToCamel} from './utils';\n\ninterface MapPropOptions {\n  attributePrefix?: string;\n  splitValues?: boolean;\n}\n\nexport function MapProp(opts?: MapPropOptions) {\n  return (component: ComponentInterface, variableName: string) => {\n    const {componentWillLoad} = component;\n    if (!componentWillLoad) {\n      console.error(\n        'The \"componentWillLoad\" lifecycle method has to be defined for the MapProp decorator to work.'\n      );\n      return;\n    }\n\n    component.componentWillLoad = function () {\n      const prefix = (opts && opts.attributePrefix) || variableName;\n      const variable = this[variableName];\n      const attributes = getElement(this).attributes;\n      mapAttributesToProp(\n        prefix,\n        variable,\n        Array.from(attributes),\n        opts?.splitValues ?? false\n      );\n      componentWillLoad.call(this);\n    };\n  };\n}\n\nexport function ArrayProp() {\n  return (component: ComponentInterface, variableName: string) => {\n    const {componentWillLoad} = component;\n\n    const attributeWithBrackets = camelToKebab(variableName);\n\n    component.componentWillLoad = function () {\n      const value = this[variableName];\n      if (!value || isArray(value)) {\n        componentWillLoad?.call(this);\n        return;\n      }\n\n      try {\n        const valueAsArray = JSON.parse(value);\n        if (isArray(valueAsArray)) {\n          this[variableName] = valueAsArray;\n        } else {\n          console.error(\n            `Property ${attributeWithBrackets} should be an array`,\n            getElement(this)\n          );\n        }\n      } catch (e) {\n        console.error(\n          `Error while parsing attribute ${attributeWithBrackets} as array`,\n          e\n        );\n      }\n\n      componentWillLoad?.call(this);\n    };\n  };\n}\n\nfunction splitAttributeValueOnCommas(attributeValue: string) {\n  const splitButIgnoreEscapeSymbolsExpression = /(?:\\\\.|[^,])+/g;\n  const [...valuesWithEscapeSymbols] =\n    attributeValue.matchAll(splitButIgnoreEscapeSymbolsExpression) ?? [];\n\n  const removeEscapeSymbolsExpression = /\\\\(.)/g;\n  return valuesWithEscapeSymbols.map(([valuesWithEscapeSymbols]) =>\n    valuesWithEscapeSymbols.replace(removeEscapeSymbolsExpression, '$1')\n  );\n}\n\nexport function mapAttributesToProp(\n  prefix: string,\n  mapVariable: Record<string, string | string[]>,\n  attributes: {name: string; value: string}[],\n  splitValues: boolean\n) {\n  const map = attributesToStringMap(prefix, attributes);\n  Object.assign(\n    mapVariable,\n    splitValues ? stringMapToStringArrayMap(map) : map\n  );\n}\n\nfunction stringMapToStringArrayMap(map: Record<string, string>) {\n  return Object.entries(map).reduce(\n    (acc, [key, value]) => ({\n      ...acc,\n      [key]: splitAttributeValueOnCommas(value).map((subValue) =>\n        subValue.trim()\n      ),\n    }),\n    {}\n  );\n}\n\nfunction attributesToStringMap(\n  prefix: string,\n  attributes: {name: string; value: string}[]\n) {\n  const mapVariable: Record<string, string> = {};\n  const kebabPrefix = camelToKebab(prefix) + '-';\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.name.indexOf(kebabPrefix) !== 0) {\n      continue;\n    }\n\n    const property = kebabToCamel(attribute.name.replace(kebabPrefix, ''));\n    mapVariable[property] = `${attribute.value}`;\n  }\n  return mapVariable;\n}\n"],"mappings":"4HASgBA,EAAQC,GACtB,MAAO,CAACC,EAA+BC,KACrC,MAAMC,kBAACA,GAAqBF,EAC5B,IAAKE,EAAmB,CACtBC,QAAQC,MACN,iGAEF,M,CAGFJ,EAAUE,kBAAoB,W,MAC5B,MAAMG,EAAUN,GAAQA,EAAKO,iBAAoBL,EACjD,MAAMM,EAAWC,KAAKP,GACtB,MAAMQ,EAAaC,EAAWF,MAAMC,WACpCE,EACEN,EACAE,EACAK,MAAMC,KAAKJ,IACXK,EAAAf,IAAI,MAAJA,SAAI,SAAJA,EAAMgB,eAAW,MAAAD,SAAA,EAAAA,EAAI,OAEvBZ,EAAkBc,KAAKR,K,CACxB,CAEL,C,SAEgBS,IACd,MAAO,CAACjB,EAA+BC,KACrC,MAAMC,kBAACA,GAAqBF,EAE5B,MAAMkB,EAAwBC,EAAalB,GAE3CD,EAAUE,kBAAoB,WAC5B,MAAMkB,EAAQZ,KAAKP,GACnB,IAAKmB,GAASC,EAAQD,GAAQ,CAC5BlB,IAAiB,MAAjBA,SAAiB,SAAjBA,EAAmBc,KAAKR,MACxB,M,CAGF,IACE,MAAMc,EAAeC,KAAKC,MAAMJ,GAChC,GAAIC,EAAQC,GAAe,CACzBd,KAAKP,GAAgBqB,C,KAChB,CACLnB,QAAQC,MACN,YAAYc,uBACZR,EAAWF,M,EAGf,MAAOiB,GACPtB,QAAQC,MACN,iCAAiCc,aACjCO,E,CAIJvB,IAAiB,MAAjBA,SAAiB,SAAjBA,EAAmBc,KAAKR,K,CACzB,CAEL,CAEA,SAASkB,EAA4BC,G,MACnC,MAAMC,EAAwC,iBAC9C,SAAUC,IACRf,EAAAa,EAAeG,SAASF,MAAsC,MAAAd,SAAA,EAAAA,EAAI,GAEpE,MAAMiB,EAAgC,SACtC,OAAOF,EAAwBG,KAAI,EAAEH,KACnCA,EAAwBI,QAAQF,EAA+B,OAEnE,C,SAEgBpB,EACdN,EACA6B,EACAzB,EACAM,GAEA,MAAMiB,EAAMG,EAAsB9B,EAAQI,GAC1C2B,OAAOC,OACLH,EACAnB,EAAcuB,EAA0BN,GAAOA,EAEnD,CAEA,SAASM,EAA0BN,GACjC,OAAOI,OAAOG,QAAQP,GAAKQ,QACzB,CAACC,GAAMC,EAAKtB,MAAM,IACbqB,EACHC,CAACA,GAAMhB,EAA4BN,GAAOY,KAAKW,GAC7CA,EAASC,YAGb,GAEJ,CAEA,SAAST,EACP9B,EACAI,GAEA,MAAMyB,EAAsC,GAC5C,MAAMW,EAAc1B,EAAad,GAAU,IAC3C,IAAK,IAAIyC,EAAI,EAAGA,EAAIrC,EAAWsC,OAAQD,IAAK,CAC1C,MAAME,EAAYvC,EAAWqC,GAC7B,GAAIE,EAAUC,KAAKC,QAAQL,KAAiB,EAAG,CAC7C,Q,CAGF,MAAMM,EAAWC,EAAaJ,EAAUC,KAAKhB,QAAQY,EAAa,KAClEX,EAAYiB,GAAY,GAAGH,EAAU5B,O,CAEvC,OAAOc,CACT,Q"}