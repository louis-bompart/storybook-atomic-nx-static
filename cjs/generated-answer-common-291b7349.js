'use strict';

const index = require('./index-c930d4b4.js');
const localStorageUtils = require('./local-storage-utils-f2621dfd.js');
const heading = require('./heading-db5d34c0.js');
const button = require('./button-90bb3acf.js');
const utils = require('./utils-93ea935e.js');
const _commonjsHelpers = require('./_commonjsHelpers-0192c5b3.js');
const arrowBottomRounded = require('./arrow-bottom-rounded-705a1b2c.js');
const arrowTopRounded = require('./arrow-top-rounded-e7a05d2f.js');

const Switch = (props) => {
    const attributes = {
        onClick: () => { var _a; return (_a = props.onToggle) === null || _a === void 0 ? void 0 : _a.call(props, !props.checked); },
        'arial-label': props.ariaLabel,
        'aria-checked': String(!!props.checked),
        part: props.part,
        tabIndex: props.tabIndex,
        title: props.title,
    };
    const containerClasses = [
        'w-12',
        'h-6',
        'p-1',
        'rounded-full',
        props.checked ? 'bg-primary' : 'bg-neutral',
    ].join(' ');
    const handleClasses = [
        'w-4',
        'h-4',
        'rounded-full',
        'bg-white',
        props.checked ? 'ml-6' : '',
    ].join(' ');
    const buttonClasses = [
        'rounded-full',
        'btn-outline-neutral',
        props.withToggle ? 'flex' : 'hidden',
    ].join(' ');
    return (index.h("button", { role: "switch", ...attributes, class: buttonClasses },
        index.h("div", { class: containerClasses },
            index.h("div", { class: handleClasses }))));
};

const CopyIcon = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="1.5" y="1.50024" width="9" height="10" rx="1.5" stroke="currentColor"/>
<path d="M3.5 8.50024H8.5" stroke="currentColor" stroke-linecap="round"/>
<path d="M3.5 4.50024L8.5 4.50024" stroke="currentColor" stroke-linecap="round"/>
<path d="M3.5 6.50024L8.5 6.50024" stroke="currentColor" stroke-linecap="round"/>
<path d="M4.5 14.5002L11.5 14.5002C12.6046 14.5002 13.5 13.6048 13.5 12.5002L13.5 5.50024" stroke="currentColor" stroke-linecap="round"/>
</svg>
`;

const CopyButton = (props) => {
    return (index.h(button.Button, { title: props.title, part: "copy-button", style: 'text-transparent', class: `p-2 rounded-md ${props.isCopied ? 'copied' : ''} ${props.error ? 'error' : ''}`, onClick: props.onClick },
        index.h("div", { class: "icon-container text-neutral-dark" },
            index.h("atomic-icon", { class: "w-5", icon: CopyIcon }))));
};

const Thumbs = `<svg
   width="14"
   height="14"
   viewBox="0 0 14 14"
   fill="none"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <path
     class="line"
     d="m 11.00003,8.49978 h 0.5 c 0.55229,0 1,0.44771 1,1 v 0 c 0,0.55228 -0.44771,1 -1,1 L 10,10.49996 h 1 c 0.55228,0 0.99999,0.44771 1,1 v 0 c 0,0.55228 -0.44772,1 -1,1 H 9.5 l -3.52786,-6e-5 c -0.31049,0 -0.61672,-0.07229 -0.89443,-0.21115 L 3.5,11.4999 m 0,-6.5 c 0,-0.2761 -0.2239,-0.5 -0.5,-0.5 H 1 c -0.2761,0 -0.5,0.2239 -0.5,0.5 v 7 c 0,0.27614 0.2239,0.5 0.5,0.5 h 2 c 0.2761,0 0.5,-0.22386 0.5,-0.5 v -0.5 -6.5 h 0.9415 c 0.3471,10e-6 0.6694,-0.18 0.85145,-0.4755 L 6.48493,2.5895 C 6.49482,2.5735 6.50005,2.555 6.50005,2.5361 L 6.50004,1.477 C 6.50004,0.9374 6.93748,0.5 7.47709,0.5 v 0 c 0.32669,0 0.63296,0.165 0.81417,0.4368 v 0 C 8.7432,1.6147 8.91025,2.4487 8.75047,3.2476 L 8.5000098,4.498621 12.5,4.497321 c 0,0 1,-0.07687 1,0.9999998 0,0.983123 -1,1 -1,1 l -2.460584,0.00258 h 2 c 0.55228,0 1,0.44772 1,1 v 0 c 0,0.55228 -0.44772,1 -1,1 h -2"
     stroke="currentColor"
     stroke-linecap="round"
     stroke-linejoin="round"
     id="path1" />
</svg>
`;

const FeedbackButton = (props) => {
    return (index.h(button.Button, { title: props.title, style: "text-transparent", part: "feedback-button", class: `feedback-button p-2 rounded-md ${props.variant} ${props.active ? 'active' : ''}`, onClick: props.onClick, ariaPressed: `${props.active}` },
        index.h("atomic-icon", { class: "w-5", icon: Thumbs })));
};

var marked_umd = {exports: {}};

/**
 * marked v12.0.2 - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

(function (module, exports) {
/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
    factory(exports) ;
})(_commonjsHelpers.commonjsGlobal, (function (exports) {
    /**
     * Gets the original marked default options.
     */
    function _getDefaults() {
        return {
            async: false,
            breaks: false,
            extensions: null,
            gfm: true,
            hooks: null,
            pedantic: false,
            renderer: null,
            silent: false,
            tokenizer: null,
            walkTokens: null
        };
    }
    exports.defaults = _getDefaults();
    function changeDefaults(newDefaults) {
        exports.defaults = newDefaults;
    }

    /**
     * Helpers
     */
    const escapeTest = /[&<>"']/;
    const escapeReplace = new RegExp(escapeTest.source, 'g');
    const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
    const escapeReplacements = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape$1(html, encode) {
        if (encode) {
            if (escapeTest.test(html)) {
                return html.replace(escapeReplace, getEscapeReplacement);
            }
        }
        else {
            if (escapeTestNoEncode.test(html)) {
                return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
            }
        }
        return html;
    }
    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html) {
        // explicitly match decimal, hex, and named HTML entities
        return html.replace(unescapeTest, (_, n) => {
            n = n.toLowerCase();
            if (n === 'colon')
                return ':';
            if (n.charAt(0) === '#') {
                return n.charAt(1) === 'x'
                    ? String.fromCharCode(parseInt(n.substring(2), 16))
                    : String.fromCharCode(+n.substring(1));
            }
            return '';
        });
    }
    const caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
        let source = typeof regex === 'string' ? regex : regex.source;
        opt = opt || '';
        const obj = {
            replace: (name, val) => {
                let valSource = typeof val === 'string' ? val : val.source;
                valSource = valSource.replace(caret, '$1');
                source = source.replace(name, valSource);
                return obj;
            },
            getRegex: () => {
                return new RegExp(source, opt);
            }
        };
        return obj;
    }
    function cleanUrl(href) {
        try {
            href = encodeURI(href).replace(/%25/g, '%');
        }
        catch (e) {
            return null;
        }
        return href;
    }
    const noopTest = { exec: () => null };
    function splitCells(tableRow, count) {
        // ensure that every cell-delimiting pipe has a space
        // before it to distinguish it from an escaped pipe
        const row = tableRow.replace(/\|/g, (match, offset, str) => {
            let escaped = false;
            let curr = offset;
            while (--curr >= 0 && str[curr] === '\\')
                escaped = !escaped;
            if (escaped) {
                // odd number of slashes means | is escaped
                // so we leave it alone
                return '|';
            }
            else {
                // add space before unescaped |
                return ' |';
            }
        }), cells = row.split(/ \|/);
        let i = 0;
        // First/last cell in a row cannot be empty if it has no leading/trailing pipe
        if (!cells[0].trim()) {
            cells.shift();
        }
        if (cells.length > 0 && !cells[cells.length - 1].trim()) {
            cells.pop();
        }
        if (count) {
            if (cells.length > count) {
                cells.splice(count);
            }
            else {
                while (cells.length < count)
                    cells.push('');
            }
        }
        for (; i < cells.length; i++) {
            // leading or trailing whitespace is ignored per the gfm spec
            cells[i] = cells[i].trim().replace(/\\\|/g, '|');
        }
        return cells;
    }
    /**
     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
     * /c*$/ is vulnerable to REDOS.
     *
     * @param str
     * @param c
     * @param invert Remove suffix of non-c chars instead. Default falsey.
     */
    function rtrim(str, c, invert) {
        const l = str.length;
        if (l === 0) {
            return '';
        }
        // Length of suffix matching the invert condition.
        let suffLen = 0;
        // Step left until we fail to match the invert condition.
        while (suffLen < l) {
            const currChar = str.charAt(l - suffLen - 1);
            if (currChar === c && !invert) {
                suffLen++;
            }
            else if (currChar !== c && invert) {
                suffLen++;
            }
            else {
                break;
            }
        }
        return str.slice(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
        if (str.indexOf(b[1]) === -1) {
            return -1;
        }
        let level = 0;
        for (let i = 0; i < str.length; i++) {
            if (str[i] === '\\') {
                i++;
            }
            else if (str[i] === b[0]) {
                level++;
            }
            else if (str[i] === b[1]) {
                level--;
                if (level < 0) {
                    return i;
                }
            }
        }
        return -1;
    }

    function outputLink(cap, link, raw, lexer) {
        const href = link.href;
        const title = link.title ? escape$1(link.title) : null;
        const text = cap[1].replace(/\\([\[\]])/g, '$1');
        if (cap[0].charAt(0) !== '!') {
            lexer.state.inLink = true;
            const token = {
                type: 'link',
                raw,
                href,
                title,
                text,
                tokens: lexer.inlineTokens(text)
            };
            lexer.state.inLink = false;
            return token;
        }
        return {
            type: 'image',
            raw,
            href,
            title,
            text: escape$1(text)
        };
    }
    function indentCodeCompensation(raw, text) {
        const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
        if (matchIndentToCode === null) {
            return text;
        }
        const indentToCode = matchIndentToCode[1];
        return text
            .split('\n')
            .map(node => {
            const matchIndentInNode = node.match(/^\s+/);
            if (matchIndentInNode === null) {
                return node;
            }
            const [indentInNode] = matchIndentInNode;
            if (indentInNode.length >= indentToCode.length) {
                return node.slice(indentToCode.length);
            }
            return node;
        })
            .join('\n');
    }
    /**
     * Tokenizer
     */
    class _Tokenizer {
        options;
        rules; // set by the lexer
        lexer; // set by the lexer
        constructor(options) {
            this.options = options || exports.defaults;
        }
        space(src) {
            const cap = this.rules.block.newline.exec(src);
            if (cap && cap[0].length > 0) {
                return {
                    type: 'space',
                    raw: cap[0]
                };
            }
        }
        code(src) {
            const cap = this.rules.block.code.exec(src);
            if (cap) {
                const text = cap[0].replace(/^ {1,4}/gm, '');
                return {
                    type: 'code',
                    raw: cap[0],
                    codeBlockStyle: 'indented',
                    text: !this.options.pedantic
                        ? rtrim(text, '\n')
                        : text
                };
            }
        }
        fences(src) {
            const cap = this.rules.block.fences.exec(src);
            if (cap) {
                const raw = cap[0];
                const text = indentCodeCompensation(raw, cap[3] || '');
                return {
                    type: 'code',
                    raw,
                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                    text
                };
            }
        }
        heading(src) {
            const cap = this.rules.block.heading.exec(src);
            if (cap) {
                let text = cap[2].trim();
                // remove trailing #s
                if (/#$/.test(text)) {
                    const trimmed = rtrim(text, '#');
                    if (this.options.pedantic) {
                        text = trimmed.trim();
                    }
                    else if (!trimmed || / $/.test(trimmed)) {
                        // CommonMark requires space before trailing #s
                        text = trimmed.trim();
                    }
                }
                return {
                    type: 'heading',
                    raw: cap[0],
                    depth: cap[1].length,
                    text,
                    tokens: this.lexer.inline(text)
                };
            }
        }
        hr(src) {
            const cap = this.rules.block.hr.exec(src);
            if (cap) {
                return {
                    type: 'hr',
                    raw: cap[0]
                };
            }
        }
        blockquote(src) {
            const cap = this.rules.block.blockquote.exec(src);
            if (cap) {
                // precede setext continuation with 4 spaces so it isn't a setext
                let text = cap[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, '\n    $1');
                text = rtrim(text.replace(/^ *>[ \t]?/gm, ''), '\n');
                const top = this.lexer.state.top;
                this.lexer.state.top = true;
                const tokens = this.lexer.blockTokens(text);
                this.lexer.state.top = top;
                return {
                    type: 'blockquote',
                    raw: cap[0],
                    tokens,
                    text
                };
            }
        }
        list(src) {
            let cap = this.rules.block.list.exec(src);
            if (cap) {
                let bull = cap[1].trim();
                const isordered = bull.length > 1;
                const list = {
                    type: 'list',
                    raw: '',
                    ordered: isordered,
                    start: isordered ? +bull.slice(0, -1) : '',
                    loose: false,
                    items: []
                };
                bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
                if (this.options.pedantic) {
                    bull = isordered ? bull : '[*+-]';
                }
                // Get next list item
                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);
                let raw = '';
                let itemContents = '';
                let endsWithBlankLine = false;
                // Check if current bullet point can start a new List Item
                while (src) {
                    let endEarly = false;
                    if (!(cap = itemRegex.exec(src))) {
                        break;
                    }
                    if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
                        break;
                    }
                    raw = cap[0];
                    src = src.substring(raw.length);
                    let line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
                    let nextLine = src.split('\n', 1)[0];
                    let indent = 0;
                    if (this.options.pedantic) {
                        indent = 2;
                        itemContents = line.trimStart();
                    }
                    else {
                        indent = cap[2].search(/[^ ]/); // Find first non-space char
                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                        itemContents = line.slice(indent);
                        indent += cap[1].length;
                    }
                    let blankLine = false;
                    if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
                        raw += nextLine + '\n';
                        src = src.substring(nextLine.length + 1);
                        endEarly = true;
                    }
                    if (!endEarly) {
                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
                        // Check if following lines should be included in List Item
                        while (src) {
                            const rawLine = src.split('\n', 1)[0];
                            nextLine = rawLine;
                            // Re-align to follow commonmark nesting rules
                            if (this.options.pedantic) {
                                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                            }
                            // End list item if found code fences
                            if (fencesBeginRegex.test(nextLine)) {
                                break;
                            }
                            // End list item if found start of new heading
                            if (headingBeginRegex.test(nextLine)) {
                                break;
                            }
                            // End list item if found start of new bullet
                            if (nextBulletRegex.test(nextLine)) {
                                break;
                            }
                            // Horizontal rule found
                            if (hrRegex.test(src)) {
                                break;
                            }
                            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible
                                itemContents += '\n' + nextLine.slice(indent);
                            }
                            else {
                                // not enough indentation
                                if (blankLine) {
                                    break;
                                }
                                // paragraph continuation unless last line was a different block level element
                                if (line.search(/[^ ]/) >= 4) { // indented code block
                                    break;
                                }
                                if (fencesBeginRegex.test(line)) {
                                    break;
                                }
                                if (headingBeginRegex.test(line)) {
                                    break;
                                }
                                if (hrRegex.test(line)) {
                                    break;
                                }
                                itemContents += '\n' + nextLine;
                            }
                            if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                                blankLine = true;
                            }
                            raw += rawLine + '\n';
                            src = src.substring(rawLine.length + 1);
                            line = nextLine.slice(indent);
                        }
                    }
                    if (!list.loose) {
                        // If the previous item ended with a blank line, the list is loose
                        if (endsWithBlankLine) {
                            list.loose = true;
                        }
                        else if (/\n *\n *$/.test(raw)) {
                            endsWithBlankLine = true;
                        }
                    }
                    let istask = null;
                    let ischecked;
                    // Check for task list items
                    if (this.options.gfm) {
                        istask = /^\[[ xX]\] /.exec(itemContents);
                        if (istask) {
                            ischecked = istask[0] !== '[ ] ';
                            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
                        }
                    }
                    list.items.push({
                        type: 'list_item',
                        raw,
                        task: !!istask,
                        checked: ischecked,
                        loose: false,
                        text: itemContents,
                        tokens: []
                    });
                    list.raw += raw;
                }
                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
                list.items[list.items.length - 1].raw = raw.trimEnd();
                (list.items[list.items.length - 1]).text = itemContents.trimEnd();
                list.raw = list.raw.trimEnd();
                // Item child tokens handled here at end because we needed to have the final item to trim it first
                for (let i = 0; i < list.items.length; i++) {
                    this.lexer.state.top = false;
                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                    if (!list.loose) {
                        // Check if list should be loose
                        const spacers = list.items[i].tokens.filter(t => t.type === 'space');
                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));
                        list.loose = hasMultipleLineBreaks;
                    }
                }
                // Set all items to loose if list is loose
                if (list.loose) {
                    for (let i = 0; i < list.items.length; i++) {
                        list.items[i].loose = true;
                    }
                }
                return list;
            }
        }
        html(src) {
            const cap = this.rules.block.html.exec(src);
            if (cap) {
                const token = {
                    type: 'html',
                    block: true,
                    raw: cap[0],
                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                    text: cap[0]
                };
                return token;
            }
        }
        def(src) {
            const cap = this.rules.block.def.exec(src);
            if (cap) {
                const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
                return {
                    type: 'def',
                    tag,
                    raw: cap[0],
                    href,
                    title
                };
            }
        }
        table(src) {
            const cap = this.rules.block.table.exec(src);
            if (!cap) {
                return;
            }
            if (!/[:|]/.test(cap[2])) {
                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
                return;
            }
            const headers = splitCells(cap[1]);
            const aligns = cap[2].replace(/^\||\| *$/g, '').split('|');
            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : [];
            const item = {
                type: 'table',
                raw: cap[0],
                header: [],
                align: [],
                rows: []
            };
            if (headers.length !== aligns.length) {
                // header and align columns must be equal, rows can be different.
                return;
            }
            for (const align of aligns) {
                if (/^ *-+: *$/.test(align)) {
                    item.align.push('right');
                }
                else if (/^ *:-+: *$/.test(align)) {
                    item.align.push('center');
                }
                else if (/^ *:-+ *$/.test(align)) {
                    item.align.push('left');
                }
                else {
                    item.align.push(null);
                }
            }
            for (const header of headers) {
                item.header.push({
                    text: header,
                    tokens: this.lexer.inline(header)
                });
            }
            for (const row of rows) {
                item.rows.push(splitCells(row, item.header.length).map(cell => {
                    return {
                        text: cell,
                        tokens: this.lexer.inline(cell)
                    };
                }));
            }
            return item;
        }
        lheading(src) {
            const cap = this.rules.block.lheading.exec(src);
            if (cap) {
                return {
                    type: 'heading',
                    raw: cap[0],
                    depth: cap[2].charAt(0) === '=' ? 1 : 2,
                    text: cap[1],
                    tokens: this.lexer.inline(cap[1])
                };
            }
        }
        paragraph(src) {
            const cap = this.rules.block.paragraph.exec(src);
            if (cap) {
                const text = cap[1].charAt(cap[1].length - 1) === '\n'
                    ? cap[1].slice(0, -1)
                    : cap[1];
                return {
                    type: 'paragraph',
                    raw: cap[0],
                    text,
                    tokens: this.lexer.inline(text)
                };
            }
        }
        text(src) {
            const cap = this.rules.block.text.exec(src);
            if (cap) {
                return {
                    type: 'text',
                    raw: cap[0],
                    text: cap[0],
                    tokens: this.lexer.inline(cap[0])
                };
            }
        }
        escape(src) {
            const cap = this.rules.inline.escape.exec(src);
            if (cap) {
                return {
                    type: 'escape',
                    raw: cap[0],
                    text: escape$1(cap[1])
                };
            }
        }
        tag(src) {
            const cap = this.rules.inline.tag.exec(src);
            if (cap) {
                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
                    this.lexer.state.inLink = true;
                }
                else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
                    this.lexer.state.inLink = false;
                }
                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                    this.lexer.state.inRawBlock = true;
                }
                else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                    this.lexer.state.inRawBlock = false;
                }
                return {
                    type: 'html',
                    raw: cap[0],
                    inLink: this.lexer.state.inLink,
                    inRawBlock: this.lexer.state.inRawBlock,
                    block: false,
                    text: cap[0]
                };
            }
        }
        link(src) {
            const cap = this.rules.inline.link.exec(src);
            if (cap) {
                const trimmedUrl = cap[2].trim();
                if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                    // commonmark requires matching angle brackets
                    if (!(/>$/.test(trimmedUrl))) {
                        return;
                    }
                    // ending angle bracket cannot be escaped
                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                        return;
                    }
                }
                else {
                    // find closing parenthesis
                    const lastParenIndex = findClosingBracket(cap[2], '()');
                    if (lastParenIndex > -1) {
                        const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                        const linkLen = start + cap[1].length + lastParenIndex;
                        cap[2] = cap[2].substring(0, lastParenIndex);
                        cap[0] = cap[0].substring(0, linkLen).trim();
                        cap[3] = '';
                    }
                }
                let href = cap[2];
                let title = '';
                if (this.options.pedantic) {
                    // split pedantic href and title
                    const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                    if (link) {
                        href = link[1];
                        title = link[3];
                    }
                }
                else {
                    title = cap[3] ? cap[3].slice(1, -1) : '';
                }
                href = href.trim();
                if (/^</.test(href)) {
                    if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
                        // pedantic allows starting angle bracket without ending angle bracket
                        href = href.slice(1);
                    }
                    else {
                        href = href.slice(1, -1);
                    }
                }
                return outputLink(cap, {
                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title
                }, cap[0], this.lexer);
            }
        }
        reflink(src, links) {
            let cap;
            if ((cap = this.rules.inline.reflink.exec(src))
                || (cap = this.rules.inline.nolink.exec(src))) {
                const linkString = (cap[2] || cap[1]).replace(/\s+/g, ' ');
                const link = links[linkString.toLowerCase()];
                if (!link) {
                    const text = cap[0].charAt(0);
                    return {
                        type: 'text',
                        raw: text,
                        text
                    };
                }
                return outputLink(cap, link, cap[0], this.lexer);
            }
        }
        emStrong(src, maskedSrc, prevChar = '') {
            let match = this.rules.inline.emStrongLDelim.exec(src);
            if (!match)
                return;
            // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
            if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
                return;
            const nextChar = match[1] || match[2] || '';
            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
                const lLength = [...match[0]].length - 1;
                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
                const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
                endReg.lastIndex = 0;
                // Clip maskedSrc to same section of string as src (move to lexer?)
                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
                while ((match = endReg.exec(maskedSrc)) != null) {
                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                    if (!rDelim)
                        continue; // skip single * in __abc*abc__
                    rLength = [...rDelim].length;
                    if (match[3] || match[4]) { // found another Left Delim
                        delimTotal += rLength;
                        continue;
                    }
                    else if (match[5] || match[6]) { // either Left or Right Delim
                        if (lLength % 3 && !((lLength + rLength) % 3)) {
                            midDelimTotal += rLength;
                            continue; // CommonMark Emphasis Rules 9-10
                        }
                    }
                    delimTotal -= rLength;
                    if (delimTotal > 0)
                        continue; // Haven't found enough closing delimiters
                    // Remove extra characters. *a*** -> *a*
                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                    // char length can be >1 for unicode characters;
                    const lastCharLength = [...match[0]][0].length;
                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                    // Create `em` if smallest delimiter has odd char count. *a***
                    if (Math.min(lLength, rLength) % 2) {
                        const text = raw.slice(1, -1);
                        return {
                            type: 'em',
                            raw,
                            text,
                            tokens: this.lexer.inlineTokens(text)
                        };
                    }
                    // Create 'strong' if smallest delimiter has even char count. **a***
                    const text = raw.slice(2, -2);
                    return {
                        type: 'strong',
                        raw,
                        text,
                        tokens: this.lexer.inlineTokens(text)
                    };
                }
            }
        }
        codespan(src) {
            const cap = this.rules.inline.code.exec(src);
            if (cap) {
                let text = cap[2].replace(/\n/g, ' ');
                const hasNonSpaceChars = /[^ ]/.test(text);
                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                    text = text.substring(1, text.length - 1);
                }
                text = escape$1(text, true);
                return {
                    type: 'codespan',
                    raw: cap[0],
                    text
                };
            }
        }
        br(src) {
            const cap = this.rules.inline.br.exec(src);
            if (cap) {
                return {
                    type: 'br',
                    raw: cap[0]
                };
            }
        }
        del(src) {
            const cap = this.rules.inline.del.exec(src);
            if (cap) {
                return {
                    type: 'del',
                    raw: cap[0],
                    text: cap[2],
                    tokens: this.lexer.inlineTokens(cap[2])
                };
            }
        }
        autolink(src) {
            const cap = this.rules.inline.autolink.exec(src);
            if (cap) {
                let text, href;
                if (cap[2] === '@') {
                    text = escape$1(cap[1]);
                    href = 'mailto:' + text;
                }
                else {
                    text = escape$1(cap[1]);
                    href = text;
                }
                return {
                    type: 'link',
                    raw: cap[0],
                    text,
                    href,
                    tokens: [
                        {
                            type: 'text',
                            raw: text,
                            text
                        }
                    ]
                };
            }
        }
        url(src) {
            let cap;
            if (cap = this.rules.inline.url.exec(src)) {
                let text, href;
                if (cap[2] === '@') {
                    text = escape$1(cap[0]);
                    href = 'mailto:' + text;
                }
                else {
                    // do extended autolink path validation
                    let prevCapZero;
                    do {
                        prevCapZero = cap[0];
                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                    } while (prevCapZero !== cap[0]);
                    text = escape$1(cap[0]);
                    if (cap[1] === 'www.') {
                        href = 'http://' + cap[0];
                    }
                    else {
                        href = cap[0];
                    }
                }
                return {
                    type: 'link',
                    raw: cap[0],
                    text,
                    href,
                    tokens: [
                        {
                            type: 'text',
                            raw: text,
                            text
                        }
                    ]
                };
            }
        }
        inlineText(src) {
            const cap = this.rules.inline.text.exec(src);
            if (cap) {
                let text;
                if (this.lexer.state.inRawBlock) {
                    text = cap[0];
                }
                else {
                    text = escape$1(cap[0]);
                }
                return {
                    type: 'text',
                    raw: cap[0],
                    text
                };
            }
        }
    }

    /**
     * Block-Level Grammar
     */
    const newline = /^(?: *(?:\n|$))+/;
    const blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
    const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
    const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
    const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
    const bullet = /(?:[*+-]|\d{1,9}[.)])/;
    const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/)
        .replace(/bull/g, bullet) // lists can interrupt
        .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt
        .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
        .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
        .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
        .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
        .getRegex();
    const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
    const blockText = /^[^\n]+/;
    const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    const def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
        .replace('label', _blockLabel)
        .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
        .getRegex();
    const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
        .replace(/bull/g, bullet)
        .getRegex();
    const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'
        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
        + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'
        + '|tr|track|ul';
    const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
    const html = edit('^ {0,3}(?:' // optional indentation
        + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
        + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
        + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
        + ')', 'i')
        .replace('comment', _comment)
        .replace('tag', _tag)
        .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
        .getRegex();
    const paragraph = edit(_paragraph)
        .replace('hr', hr)
        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
        .replace('|table', '')
        .replace('blockquote', ' {0,3}>')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
        .getRegex();
    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
        .replace('paragraph', paragraph)
        .getRegex();
    /**
     * Normal Block Grammar
     */
    const blockNormal = {
        blockquote,
        code: blockCode,
        def,
        fences,
        heading,
        hr,
        html,
        lheading,
        list,
        newline,
        paragraph,
        table: noopTest,
        text: blockText
    };
    /**
     * GFM Block Grammar
     */
    const gfmTable = edit('^ *([^\\n ].*)\\n' // Header
        + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
        + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)') // Cells
        .replace('hr', hr)
        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
        .replace('blockquote', ' {0,3}>')
        .replace('code', ' {4}[^\\n]')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', _tag) // tables can be interrupted by type (6) html blocks
        .getRegex();
    const blockGfm = {
        ...blockNormal,
        table: gfmTable,
        paragraph: edit(_paragraph)
            .replace('hr', hr)
            .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
            .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
            .replace('table', gfmTable) // interrupt paragraphs with table
            .replace('blockquote', ' {0,3}>')
            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
            .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
            .getRegex()
    };
    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */
    const blockPedantic = {
        ...blockNormal,
        html: edit('^ *(?:comment *(?:\\n|\\s*$)'
            + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
            + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
            .replace('comment', _comment)
            .replace(/tag/g, '(?!(?:'
            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
            + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
            .getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: noopTest, // fences not supported
        lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
        paragraph: edit(_paragraph)
            .replace('hr', hr)
            .replace('heading', ' *#{1,6} *[^\n]')
            .replace('lheading', lheading)
            .replace('|table', '')
            .replace('blockquote', ' {0,3}>')
            .replace('|fences', '')
            .replace('|list', '')
            .replace('|html', '')
            .replace('|tag', '')
            .getRegex()
    };
    /**
     * Inline-Level Grammar
     */
    const escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
    const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
    const br = /^( {2,}|\\)\n(?!\s*$)/;
    const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
    // list of unicode punctuation marks, plus any missing characters from CommonMark spec
    const _punctuation = '\\p{P}\\p{S}';
    const punctuation = edit(/^((?![*_])[\spunctuation])/, 'u')
        .replace(/punctuation/g, _punctuation).getRegex();
    // sequences em should skip over [title](link), `code`, <html>
    const blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    const emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, 'u')
        .replace(/punct/g, _punctuation)
        .getRegex();
    const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' // Skip orphan inside strong
        + '|[^*]+(?=[^*])' // Consume to delim
        + '|(?!\\*)[punct](\\*+)(?=[\\s]|$)' // (1) #*** can only be a Right Delimiter
        + '|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter
        + '|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])' // (3) #***a, ***a can only be Left Delimiter
        + '|[\\s](\\*+)(?!\\*)(?=[punct])' // (4) ***# can only be Left Delimiter
        + '|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter
        + '|[^punct\\s](\\*+)(?=[^punct\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter
        .replace(/punct/g, _punctuation)
        .getRegex();
    // (6) Not allowed for _
    const emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' // Skip orphan inside strong
        + '|[^_]+(?=[^_])' // Consume to delim
        + '|(?!_)[punct](_+)(?=[\\s]|$)' // (1) #___ can only be a Right Delimiter
        + '|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter
        + '|(?!_)[punct\\s](_+)(?=[^punct\\s])' // (3) #___a, ___a can only be Left Delimiter
        + '|[\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter
        + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter
        .replace(/punct/g, _punctuation)
        .getRegex();
    const anyPunctuation = edit(/\\([punct])/, 'gu')
        .replace(/punct/g, _punctuation)
        .getRegex();
    const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
        .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
        .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
        .getRegex();
    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
    const tag = edit('^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>') // CDATA section
        .replace('comment', _inlineComment)
        .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
        .getRegex();
    const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
        .replace('label', _inlineLabel)
        .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
        .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
        .getRegex();
    const reflink = edit(/^!?\[(label)\]\[(ref)\]/)
        .replace('label', _inlineLabel)
        .replace('ref', _blockLabel)
        .getRegex();
    const nolink = edit(/^!?\[(ref)\](?:\[\])?/)
        .replace('ref', _blockLabel)
        .getRegex();
    const reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
        .replace('reflink', reflink)
        .replace('nolink', nolink)
        .getRegex();
    /**
     * Normal Inline Grammar
     */
    const inlineNormal = {
        _backpedal: noopTest, // only used for GFM url
        anyPunctuation,
        autolink,
        blockSkip,
        br,
        code: inlineCode,
        del: noopTest,
        emStrongLDelim,
        emStrongRDelimAst,
        emStrongRDelimUnd,
        escape,
        link,
        nolink,
        punctuation,
        reflink,
        reflinkSearch,
        tag,
        text: inlineText,
        url: noopTest
    };
    /**
     * Pedantic Inline Grammar
     */
    const inlinePedantic = {
        ...inlineNormal,
        link: edit(/^!?\[(label)\]\((.*?)\)/)
            .replace('label', _inlineLabel)
            .getRegex(),
        reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
            .replace('label', _inlineLabel)
            .getRegex()
    };
    /**
     * GFM Inline Grammar
     */
    const inlineGfm = {
        ...inlineNormal,
        escape: edit(escape).replace('])', '~|])').getRegex(),
        url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
            .getRegex(),
        _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    };
    /**
     * GFM + Line Breaks Inline Grammar
     */
    const inlineBreaks = {
        ...inlineGfm,
        br: edit(br).replace('{2,}', '*').getRegex(),
        text: edit(inlineGfm.text)
            .replace('\\b_', '\\b_| {2,}\\n')
            .replace(/\{2,\}/g, '*')
            .getRegex()
    };
    /**
     * exports
     */
    const block = {
        normal: blockNormal,
        gfm: blockGfm,
        pedantic: blockPedantic
    };
    const inline = {
        normal: inlineNormal,
        gfm: inlineGfm,
        breaks: inlineBreaks,
        pedantic: inlinePedantic
    };

    /**
     * Block Lexer
     */
    class _Lexer {
        tokens;
        options;
        state;
        tokenizer;
        inlineQueue;
        constructor(options) {
            // TokenList cannot be created in one go
            this.tokens = [];
            this.tokens.links = Object.create(null);
            this.options = options || exports.defaults;
            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
            this.tokenizer = this.options.tokenizer;
            this.tokenizer.options = this.options;
            this.tokenizer.lexer = this;
            this.inlineQueue = [];
            this.state = {
                inLink: false,
                inRawBlock: false,
                top: true
            };
            const rules = {
                block: block.normal,
                inline: inline.normal
            };
            if (this.options.pedantic) {
                rules.block = block.pedantic;
                rules.inline = inline.pedantic;
            }
            else if (this.options.gfm) {
                rules.block = block.gfm;
                if (this.options.breaks) {
                    rules.inline = inline.breaks;
                }
                else {
                    rules.inline = inline.gfm;
                }
            }
            this.tokenizer.rules = rules;
        }
        /**
         * Expose Rules
         */
        static get rules() {
            return {
                block,
                inline
            };
        }
        /**
         * Static Lex Method
         */
        static lex(src, options) {
            const lexer = new _Lexer(options);
            return lexer.lex(src);
        }
        /**
         * Static Lex Inline Method
         */
        static lexInline(src, options) {
            const lexer = new _Lexer(options);
            return lexer.inlineTokens(src);
        }
        /**
         * Preprocessing
         */
        lex(src) {
            src = src
                .replace(/\r\n|\r/g, '\n');
            this.blockTokens(src, this.tokens);
            for (let i = 0; i < this.inlineQueue.length; i++) {
                const next = this.inlineQueue[i];
                this.inlineTokens(next.src, next.tokens);
            }
            this.inlineQueue = [];
            return this.tokens;
        }
        blockTokens(src, tokens = []) {
            if (this.options.pedantic) {
                src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
            }
            else {
                src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
                    return leading + '    '.repeat(tabs.length);
                });
            }
            let token;
            let lastToken;
            let cutSrc;
            let lastParagraphClipped;
            while (src) {
                if (this.options.extensions
                    && this.options.extensions.block
                    && this.options.extensions.block.some((extTokenizer) => {
                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                            src = src.substring(token.raw.length);
                            tokens.push(token);
                            return true;
                        }
                        return false;
                    })) {
                    continue;
                }
                // newline
                if (token = this.tokenizer.space(src)) {
                    src = src.substring(token.raw.length);
                    if (token.raw.length === 1 && tokens.length > 0) {
                        // if there's a single \n as a spacer, it's terminating the last line,
                        // so move it there so that we don't get unnecessary paragraph tags
                        tokens[tokens.length - 1].raw += '\n';
                    }
                    else {
                        tokens.push(token);
                    }
                    continue;
                }
                // code
                if (token = this.tokenizer.code(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    // An indented code block cannot interrupt a paragraph.
                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.text;
                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    continue;
                }
                // fences
                if (token = this.tokenizer.fences(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // heading
                if (token = this.tokenizer.heading(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // hr
                if (token = this.tokenizer.hr(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // blockquote
                if (token = this.tokenizer.blockquote(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // list
                if (token = this.tokenizer.list(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // html
                if (token = this.tokenizer.html(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // def
                if (token = this.tokenizer.def(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.raw;
                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else if (!this.tokens.links[token.tag]) {
                        this.tokens.links[token.tag] = {
                            href: token.href,
                            title: token.title
                        };
                    }
                    continue;
                }
                // table (gfm)
                if (token = this.tokenizer.table(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // lheading
                if (token = this.tokenizer.lheading(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // top-level paragraph
                // prevent paragraph consuming extensions by clipping 'src' to extension start
                cutSrc = src;
                if (this.options.extensions && this.options.extensions.startBlock) {
                    let startIndex = Infinity;
                    const tempSrc = src.slice(1);
                    let tempStart;
                    this.options.extensions.startBlock.forEach((getStartIndex) => {
                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                        if (typeof tempStart === 'number' && tempStart >= 0) {
                            startIndex = Math.min(startIndex, tempStart);
                        }
                    });
                    if (startIndex < Infinity && startIndex >= 0) {
                        cutSrc = src.substring(0, startIndex + 1);
                    }
                }
                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                    lastToken = tokens[tokens.length - 1];
                    if (lastParagraphClipped && lastToken.type === 'paragraph') {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.text;
                        this.inlineQueue.pop();
                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    lastParagraphClipped = (cutSrc.length !== src.length);
                    src = src.substring(token.raw.length);
                    continue;
                }
                // text
                if (token = this.tokenizer.text(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && lastToken.type === 'text') {
                        lastToken.raw += '\n' + token.raw;
                        lastToken.text += '\n' + token.text;
                        this.inlineQueue.pop();
                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    continue;
                }
                if (src) {
                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                    if (this.options.silent) {
                        console.error(errMsg);
                        break;
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
            this.state.top = true;
            return tokens;
        }
        inline(src, tokens = []) {
            this.inlineQueue.push({ src, tokens });
            return tokens;
        }
        /**
         * Lexing/Compiling
         */
        inlineTokens(src, tokens = []) {
            let token, lastToken, cutSrc;
            // String with links masked to avoid interference with em and strong
            let maskedSrc = src;
            let match;
            let keepPrevChar, prevChar;
            // Mask out reflinks
            if (this.tokens.links) {
                const links = Object.keys(this.tokens.links);
                if (links.length > 0) {
                    while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                        if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                        }
                    }
                }
            }
            // Mask out other blocks
            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            }
            // Mask out escaped characters
            while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
                maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
            }
            while (src) {
                if (!keepPrevChar) {
                    prevChar = '';
                }
                keepPrevChar = false;
                // extensions
                if (this.options.extensions
                    && this.options.extensions.inline
                    && this.options.extensions.inline.some((extTokenizer) => {
                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                            src = src.substring(token.raw.length);
                            tokens.push(token);
                            return true;
                        }
                        return false;
                    })) {
                    continue;
                }
                // escape
                if (token = this.tokenizer.escape(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // tag
                if (token = this.tokenizer.tag(src)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                        lastToken.raw += token.raw;
                        lastToken.text += token.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    continue;
                }
                // link
                if (token = this.tokenizer.link(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // reflink, nolink
                if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                    src = src.substring(token.raw.length);
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                        lastToken.raw += token.raw;
                        lastToken.text += token.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    continue;
                }
                // em & strong
                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // code
                if (token = this.tokenizer.codespan(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // br
                if (token = this.tokenizer.br(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // del (gfm)
                if (token = this.tokenizer.del(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // autolink
                if (token = this.tokenizer.autolink(src)) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // url (gfm)
                if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    continue;
                }
                // text
                // prevent inlineText consuming extensions by clipping 'src' to extension start
                cutSrc = src;
                if (this.options.extensions && this.options.extensions.startInline) {
                    let startIndex = Infinity;
                    const tempSrc = src.slice(1);
                    let tempStart;
                    this.options.extensions.startInline.forEach((getStartIndex) => {
                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                        if (typeof tempStart === 'number' && tempStart >= 0) {
                            startIndex = Math.min(startIndex, tempStart);
                        }
                    });
                    if (startIndex < Infinity && startIndex >= 0) {
                        cutSrc = src.substring(0, startIndex + 1);
                    }
                }
                if (token = this.tokenizer.inlineText(cutSrc)) {
                    src = src.substring(token.raw.length);
                    if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
                        prevChar = token.raw.slice(-1);
                    }
                    keepPrevChar = true;
                    lastToken = tokens[tokens.length - 1];
                    if (lastToken && lastToken.type === 'text') {
                        lastToken.raw += token.raw;
                        lastToken.text += token.text;
                    }
                    else {
                        tokens.push(token);
                    }
                    continue;
                }
                if (src) {
                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                    if (this.options.silent) {
                        console.error(errMsg);
                        break;
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
            return tokens;
        }
    }

    /**
     * Renderer
     */
    class _Renderer {
        options;
        constructor(options) {
            this.options = options || exports.defaults;
        }
        code(code, infostring, escaped) {
            const lang = (infostring || '').match(/^\S*/)?.[0];
            code = code.replace(/\n$/, '') + '\n';
            if (!lang) {
                return '<pre><code>'
                    + (escaped ? code : escape$1(code, true))
                    + '</code></pre>\n';
            }
            return '<pre><code class="language-'
                + escape$1(lang)
                + '">'
                + (escaped ? code : escape$1(code, true))
                + '</code></pre>\n';
        }
        blockquote(quote) {
            return `<blockquote>\n${quote}</blockquote>\n`;
        }
        html(html, block) {
            return html;
        }
        heading(text, level, raw) {
            // ignore IDs
            return `<h${level}>${text}</h${level}>\n`;
        }
        hr() {
            return '<hr>\n';
        }
        list(body, ordered, start) {
            const type = ordered ? 'ol' : 'ul';
            const startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
            return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
        }
        listitem(text, task, checked) {
            return `<li>${text}</li>\n`;
        }
        checkbox(checked) {
            return '<input '
                + (checked ? 'checked="" ' : '')
                + 'disabled="" type="checkbox">';
        }
        paragraph(text) {
            return `<p>${text}</p>\n`;
        }
        table(header, body) {
            if (body)
                body = `<tbody>${body}</tbody>`;
            return '<table>\n'
                + '<thead>\n'
                + header
                + '</thead>\n'
                + body
                + '</table>\n';
        }
        tablerow(content) {
            return `<tr>\n${content}</tr>\n`;
        }
        tablecell(content, flags) {
            const type = flags.header ? 'th' : 'td';
            const tag = flags.align
                ? `<${type} align="${flags.align}">`
                : `<${type}>`;
            return tag + content + `</${type}>\n`;
        }
        /**
         * span level renderer
         */
        strong(text) {
            return `<strong>${text}</strong>`;
        }
        em(text) {
            return `<em>${text}</em>`;
        }
        codespan(text) {
            return `<code>${text}</code>`;
        }
        br() {
            return '<br>';
        }
        del(text) {
            return `<del>${text}</del>`;
        }
        link(href, title, text) {
            const cleanHref = cleanUrl(href);
            if (cleanHref === null) {
                return text;
            }
            href = cleanHref;
            let out = '<a href="' + href + '"';
            if (title) {
                out += ' title="' + title + '"';
            }
            out += '>' + text + '</a>';
            return out;
        }
        image(href, title, text) {
            const cleanHref = cleanUrl(href);
            if (cleanHref === null) {
                return text;
            }
            href = cleanHref;
            let out = `<img src="${href}" alt="${text}"`;
            if (title) {
                out += ` title="${title}"`;
            }
            out += '>';
            return out;
        }
        text(text) {
            return text;
        }
    }

    /**
     * TextRenderer
     * returns only the textual part of the token
     */
    class _TextRenderer {
        // no need for block level renderers
        strong(text) {
            return text;
        }
        em(text) {
            return text;
        }
        codespan(text) {
            return text;
        }
        del(text) {
            return text;
        }
        html(text) {
            return text;
        }
        text(text) {
            return text;
        }
        link(href, title, text) {
            return '' + text;
        }
        image(href, title, text) {
            return '' + text;
        }
        br() {
            return '';
        }
    }

    /**
     * Parsing & Compiling
     */
    class _Parser {
        options;
        renderer;
        textRenderer;
        constructor(options) {
            this.options = options || exports.defaults;
            this.options.renderer = this.options.renderer || new _Renderer();
            this.renderer = this.options.renderer;
            this.renderer.options = this.options;
            this.textRenderer = new _TextRenderer();
        }
        /**
         * Static Parse Method
         */
        static parse(tokens, options) {
            const parser = new _Parser(options);
            return parser.parse(tokens);
        }
        /**
         * Static Parse Inline Method
         */
        static parseInline(tokens, options) {
            const parser = new _Parser(options);
            return parser.parseInline(tokens);
        }
        /**
         * Parse Loop
         */
        parse(tokens, top = true) {
            let out = '';
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                // Run any renderer extensions
                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                    const genericToken = token;
                    const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                    if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                        out += ret || '';
                        continue;
                    }
                }
                switch (token.type) {
                    case 'space': {
                        continue;
                    }
                    case 'hr': {
                        out += this.renderer.hr();
                        continue;
                    }
                    case 'heading': {
                        const headingToken = token;
                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
                        continue;
                    }
                    case 'code': {
                        const codeToken = token;
                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
                        continue;
                    }
                    case 'table': {
                        const tableToken = token;
                        let header = '';
                        // header
                        let cell = '';
                        for (let j = 0; j < tableToken.header.length; j++) {
                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
                        }
                        header += this.renderer.tablerow(cell);
                        let body = '';
                        for (let j = 0; j < tableToken.rows.length; j++) {
                            const row = tableToken.rows[j];
                            cell = '';
                            for (let k = 0; k < row.length; k++) {
                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
                            }
                            body += this.renderer.tablerow(cell);
                        }
                        out += this.renderer.table(header, body);
                        continue;
                    }
                    case 'blockquote': {
                        const blockquoteToken = token;
                        const body = this.parse(blockquoteToken.tokens);
                        out += this.renderer.blockquote(body);
                        continue;
                    }
                    case 'list': {
                        const listToken = token;
                        const ordered = listToken.ordered;
                        const start = listToken.start;
                        const loose = listToken.loose;
                        let body = '';
                        for (let j = 0; j < listToken.items.length; j++) {
                            const item = listToken.items[j];
                            const checked = item.checked;
                            const task = item.task;
                            let itemBody = '';
                            if (item.task) {
                                const checkbox = this.renderer.checkbox(!!checked);
                                if (loose) {
                                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                                        }
                                    }
                                    else {
                                        item.tokens.unshift({
                                            type: 'text',
                                            text: checkbox + ' '
                                        });
                                    }
                                }
                                else {
                                    itemBody += checkbox + ' ';
                                }
                            }
                            itemBody += this.parse(item.tokens, loose);
                            body += this.renderer.listitem(itemBody, task, !!checked);
                        }
                        out += this.renderer.list(body, ordered, start);
                        continue;
                    }
                    case 'html': {
                        const htmlToken = token;
                        out += this.renderer.html(htmlToken.text, htmlToken.block);
                        continue;
                    }
                    case 'paragraph': {
                        const paragraphToken = token;
                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
                        continue;
                    }
                    case 'text': {
                        let textToken = token;
                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
                        while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                            textToken = tokens[++i];
                            body += '\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
                        }
                        out += top ? this.renderer.paragraph(body) : body;
                        continue;
                    }
                    default: {
                        const errMsg = 'Token with "' + token.type + '" type was not found.';
                        if (this.options.silent) {
                            console.error(errMsg);
                            return '';
                        }
                        else {
                            throw new Error(errMsg);
                        }
                    }
                }
            }
            return out;
        }
        /**
         * Parse Inline Tokens
         */
        parseInline(tokens, renderer) {
            renderer = renderer || this.renderer;
            let out = '';
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                // Run any renderer extensions
                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                    const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
                    if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
                        out += ret || '';
                        continue;
                    }
                }
                switch (token.type) {
                    case 'escape': {
                        const escapeToken = token;
                        out += renderer.text(escapeToken.text);
                        break;
                    }
                    case 'html': {
                        const tagToken = token;
                        out += renderer.html(tagToken.text);
                        break;
                    }
                    case 'link': {
                        const linkToken = token;
                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
                        break;
                    }
                    case 'image': {
                        const imageToken = token;
                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
                        break;
                    }
                    case 'strong': {
                        const strongToken = token;
                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
                        break;
                    }
                    case 'em': {
                        const emToken = token;
                        out += renderer.em(this.parseInline(emToken.tokens, renderer));
                        break;
                    }
                    case 'codespan': {
                        const codespanToken = token;
                        out += renderer.codespan(codespanToken.text);
                        break;
                    }
                    case 'br': {
                        out += renderer.br();
                        break;
                    }
                    case 'del': {
                        const delToken = token;
                        out += renderer.del(this.parseInline(delToken.tokens, renderer));
                        break;
                    }
                    case 'text': {
                        const textToken = token;
                        out += renderer.text(textToken.text);
                        break;
                    }
                    default: {
                        const errMsg = 'Token with "' + token.type + '" type was not found.';
                        if (this.options.silent) {
                            console.error(errMsg);
                            return '';
                        }
                        else {
                            throw new Error(errMsg);
                        }
                    }
                }
            }
            return out;
        }
    }

    class _Hooks {
        options;
        constructor(options) {
            this.options = options || exports.defaults;
        }
        static passThroughHooks = new Set([
            'preprocess',
            'postprocess',
            'processAllTokens'
        ]);
        /**
         * Process markdown before marked
         */
        preprocess(markdown) {
            return markdown;
        }
        /**
         * Process HTML after marked is finished
         */
        postprocess(html) {
            return html;
        }
        /**
         * Process all tokens before walk tokens
         */
        processAllTokens(tokens) {
            return tokens;
        }
    }

    class Marked {
        defaults = _getDefaults();
        options = this.setOptions;
        parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
        parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
        Parser = _Parser;
        Renderer = _Renderer;
        TextRenderer = _TextRenderer;
        Lexer = _Lexer;
        Tokenizer = _Tokenizer;
        Hooks = _Hooks;
        constructor(...args) {
            this.use(...args);
        }
        /**
         * Run callback for every token
         */
        walkTokens(tokens, callback) {
            let values = [];
            for (const token of tokens) {
                values = values.concat(callback.call(this, token));
                switch (token.type) {
                    case 'table': {
                        const tableToken = token;
                        for (const cell of tableToken.header) {
                            values = values.concat(this.walkTokens(cell.tokens, callback));
                        }
                        for (const row of tableToken.rows) {
                            for (const cell of row) {
                                values = values.concat(this.walkTokens(cell.tokens, callback));
                            }
                        }
                        break;
                    }
                    case 'list': {
                        const listToken = token;
                        values = values.concat(this.walkTokens(listToken.items, callback));
                        break;
                    }
                    default: {
                        const genericToken = token;
                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                                const tokens = genericToken[childTokens].flat(Infinity);
                                values = values.concat(this.walkTokens(tokens, callback));
                            });
                        }
                        else if (genericToken.tokens) {
                            values = values.concat(this.walkTokens(genericToken.tokens, callback));
                        }
                    }
                }
            }
            return values;
        }
        use(...args) {
            const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
            args.forEach((pack) => {
                // copy options to new object
                const opts = { ...pack };
                // set async to true if it was set to true before
                opts.async = this.defaults.async || opts.async || false;
                // ==-- Parse "addon" extensions --== //
                if (pack.extensions) {
                    pack.extensions.forEach((ext) => {
                        if (!ext.name) {
                            throw new Error('extension name required');
                        }
                        if ('renderer' in ext) { // Renderer extensions
                            const prevRenderer = extensions.renderers[ext.name];
                            if (prevRenderer) {
                                // Replace extension with func to run new extension but fall back if false
                                extensions.renderers[ext.name] = function (...args) {
                                    let ret = ext.renderer.apply(this, args);
                                    if (ret === false) {
                                        ret = prevRenderer.apply(this, args);
                                    }
                                    return ret;
                                };
                            }
                            else {
                                extensions.renderers[ext.name] = ext.renderer;
                            }
                        }
                        if ('tokenizer' in ext) { // Tokenizer Extensions
                            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                                throw new Error("extension level must be 'block' or 'inline'");
                            }
                            const extLevel = extensions[ext.level];
                            if (extLevel) {
                                extLevel.unshift(ext.tokenizer);
                            }
                            else {
                                extensions[ext.level] = [ext.tokenizer];
                            }
                            if (ext.start) { // Function to check for start of token
                                if (ext.level === 'block') {
                                    if (extensions.startBlock) {
                                        extensions.startBlock.push(ext.start);
                                    }
                                    else {
                                        extensions.startBlock = [ext.start];
                                    }
                                }
                                else if (ext.level === 'inline') {
                                    if (extensions.startInline) {
                                        extensions.startInline.push(ext.start);
                                    }
                                    else {
                                        extensions.startInline = [ext.start];
                                    }
                                }
                            }
                        }
                        if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
                            extensions.childTokens[ext.name] = ext.childTokens;
                        }
                    });
                    opts.extensions = extensions;
                }
                // ==-- Parse "overwrite" extensions --== //
                if (pack.renderer) {
                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                    for (const prop in pack.renderer) {
                        if (!(prop in renderer)) {
                            throw new Error(`renderer '${prop}' does not exist`);
                        }
                        if (prop === 'options') {
                            // ignore options property
                            continue;
                        }
                        const rendererProp = prop;
                        const rendererFunc = pack.renderer[rendererProp];
                        const prevRenderer = renderer[rendererProp];
                        // Replace renderer with func to run extension, but fall back if false
                        renderer[rendererProp] = (...args) => {
                            let ret = rendererFunc.apply(renderer, args);
                            if (ret === false) {
                                ret = prevRenderer.apply(renderer, args);
                            }
                            return ret || '';
                        };
                    }
                    opts.renderer = renderer;
                }
                if (pack.tokenizer) {
                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                    for (const prop in pack.tokenizer) {
                        if (!(prop in tokenizer)) {
                            throw new Error(`tokenizer '${prop}' does not exist`);
                        }
                        if (['options', 'rules', 'lexer'].includes(prop)) {
                            // ignore options, rules, and lexer properties
                            continue;
                        }
                        const tokenizerProp = prop;
                        const tokenizerFunc = pack.tokenizer[tokenizerProp];
                        const prevTokenizer = tokenizer[tokenizerProp];
                        // Replace tokenizer with func to run extension, but fall back if false
                        // @ts-expect-error cannot type tokenizer function dynamically
                        tokenizer[tokenizerProp] = (...args) => {
                            let ret = tokenizerFunc.apply(tokenizer, args);
                            if (ret === false) {
                                ret = prevTokenizer.apply(tokenizer, args);
                            }
                            return ret;
                        };
                    }
                    opts.tokenizer = tokenizer;
                }
                // ==-- Parse Hooks extensions --== //
                if (pack.hooks) {
                    const hooks = this.defaults.hooks || new _Hooks();
                    for (const prop in pack.hooks) {
                        if (!(prop in hooks)) {
                            throw new Error(`hook '${prop}' does not exist`);
                        }
                        if (prop === 'options') {
                            // ignore options property
                            continue;
                        }
                        const hooksProp = prop;
                        const hooksFunc = pack.hooks[hooksProp];
                        const prevHook = hooks[hooksProp];
                        if (_Hooks.passThroughHooks.has(prop)) {
                            // @ts-expect-error cannot type hook function dynamically
                            hooks[hooksProp] = (arg) => {
                                if (this.defaults.async) {
                                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                                        return prevHook.call(hooks, ret);
                                    });
                                }
                                const ret = hooksFunc.call(hooks, arg);
                                return prevHook.call(hooks, ret);
                            };
                        }
                        else {
                            // @ts-expect-error cannot type hook function dynamically
                            hooks[hooksProp] = (...args) => {
                                let ret = hooksFunc.apply(hooks, args);
                                if (ret === false) {
                                    ret = prevHook.apply(hooks, args);
                                }
                                return ret;
                            };
                        }
                    }
                    opts.hooks = hooks;
                }
                // ==-- Parse WalkTokens extensions --== //
                if (pack.walkTokens) {
                    const walkTokens = this.defaults.walkTokens;
                    const packWalktokens = pack.walkTokens;
                    opts.walkTokens = function (token) {
                        let values = [];
                        values.push(packWalktokens.call(this, token));
                        if (walkTokens) {
                            values = values.concat(walkTokens.call(this, token));
                        }
                        return values;
                    };
                }
                this.defaults = { ...this.defaults, ...opts };
            });
            return this;
        }
        setOptions(opt) {
            this.defaults = { ...this.defaults, ...opt };
            return this;
        }
        lexer(src, options) {
            return _Lexer.lex(src, options ?? this.defaults);
        }
        parser(tokens, options) {
            return _Parser.parse(tokens, options ?? this.defaults);
        }
        #parseMarkdown(lexer, parser) {
            return (src, options) => {
                const origOpt = { ...options };
                const opt = { ...this.defaults, ...origOpt };
                // Show warning if an extension set async to true but the parse was called with async: false
                if (this.defaults.async === true && origOpt.async === false) {
                    if (!opt.silent) {
                        console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');
                    }
                    opt.async = true;
                }
                const throwError = this.#onError(!!opt.silent, !!opt.async);
                // throw error in case of non string input
                if (typeof src === 'undefined' || src === null) {
                    return throwError(new Error('marked(): input parameter is undefined or null'));
                }
                if (typeof src !== 'string') {
                    return throwError(new Error('marked(): input parameter is of type '
                        + Object.prototype.toString.call(src) + ', string expected'));
                }
                if (opt.hooks) {
                    opt.hooks.options = opt;
                }
                if (opt.async) {
                    return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                        .then(src => lexer(src, opt))
                        .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)
                        .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)
                        .then(tokens => parser(tokens, opt))
                        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)
                        .catch(throwError);
                }
                try {
                    if (opt.hooks) {
                        src = opt.hooks.preprocess(src);
                    }
                    let tokens = lexer(src, opt);
                    if (opt.hooks) {
                        tokens = opt.hooks.processAllTokens(tokens);
                    }
                    if (opt.walkTokens) {
                        this.walkTokens(tokens, opt.walkTokens);
                    }
                    let html = parser(tokens, opt);
                    if (opt.hooks) {
                        html = opt.hooks.postprocess(html);
                    }
                    return html;
                }
                catch (e) {
                    return throwError(e);
                }
            };
        }
        #onError(silent, async) {
            return (e) => {
                e.message += '\nPlease report this to https://github.com/markedjs/marked.';
                if (silent) {
                    const msg = '<p>An error occurred:</p><pre>'
                        + escape$1(e.message + '', true)
                        + '</pre>';
                    if (async) {
                        return Promise.resolve(msg);
                    }
                    return msg;
                }
                if (async) {
                    return Promise.reject(e);
                }
                throw e;
            };
        }
    }

    const markedInstance = new Marked();
    function marked(src, opt) {
        return markedInstance.parse(src, opt);
    }
    /**
     * Sets the default options.
     *
     * @param options Hash of options
     */
    marked.options =
        marked.setOptions = function (options) {
            markedInstance.setOptions(options);
            marked.defaults = markedInstance.defaults;
            changeDefaults(marked.defaults);
            return marked;
        };
    /**
     * Gets the original marked default options.
     */
    marked.getDefaults = _getDefaults;
    marked.defaults = exports.defaults;
    /**
     * Use Extension
     */
    marked.use = function (...args) {
        markedInstance.use(...args);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
    };
    /**
     * Run callback for every token
     */
    marked.walkTokens = function (tokens, callback) {
        return markedInstance.walkTokens(tokens, callback);
    };
    /**
     * Compiles markdown to HTML without enclosing `p` tag.
     *
     * @param src String of markdown source to be compiled
     * @param options Hash of options
     * @return String of compiled HTML
     */
    marked.parseInline = markedInstance.parseInline;
    /**
     * Expose
     */
    marked.Parser = _Parser;
    marked.parser = _Parser.parse;
    marked.Renderer = _Renderer;
    marked.TextRenderer = _TextRenderer;
    marked.Lexer = _Lexer;
    marked.lexer = _Lexer.lex;
    marked.Tokenizer = _Tokenizer;
    marked.Hooks = _Hooks;
    marked.parse = marked;
    const options = marked.options;
    const setOptions = marked.setOptions;
    const use = marked.use;
    const walkTokens = marked.walkTokens;
    const parseInline = marked.parseInline;
    const parse = marked;
    const parser = _Parser.parse;
    const lexer = _Lexer.lex;

    exports.Hooks = _Hooks;
    exports.Lexer = _Lexer;
    exports.Marked = Marked;
    exports.Parser = _Parser;
    exports.Renderer = _Renderer;
    exports.TextRenderer = _TextRenderer;
    exports.Tokenizer = _Tokenizer;
    exports.getDefaults = _getDefaults;
    exports.lexer = lexer;
    exports.marked = marked;
    exports.options = options;
    exports.parse = parse;
    exports.parseInline = parseInline;
    exports.parser = parser;
    exports.setOptions = setOptions;
    exports.use = use;
    exports.walkTokens = walkTokens;

}));

}(marked_umd, marked_umd.exports));

const unclosedElement = /(\*{1,3}|`)($|\w[\w\s]*$)/;
const completeUnclosedElement = (text) => {
    const match = unclosedElement.exec(text);
    if (match) {
        const symbol = match[1];
        const replacements = {
            '***': '<strong part="answer-strong"><em part="answer-emphasis">$2</em></strong>',
            '**': '<strong part="answer-strong">$2</strong>',
            '*': '<em part="answer-emphasis">$2</em>',
            '`': '<code part="answer-inline-code">$2</code>',
        };
        return text.replace(unclosedElement, replacements[symbol]);
    }
    return text;
};
const escapeHtml = (text) => {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
};
const customRenderer = {
    blockquote(quote) {
        return `<blockquote part="answer-quote-block">${quote}</blockquote>`;
    },
    code(code) {
        return `<pre part="answer-code-block"><code>${escapeHtml(code)}</code></pre>`;
    },
    codespan(text) {
        return `<code part="answer-inline-code">${text}</code>`;
    },
    em(text) {
        return `<em part="answer-emphasis">${text}</em>`;
    },
    heading(text, level) {
        return `<div part="answer-heading-${level}" aria-label="${text}">${text}</div>`;
    },
    list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul';
        const part = ordered ? 'answer-ordered-list' : 'answer-unordered-list';
        const tag = ordered && start !== 1
            ? `<${type} part="${part}" start="${start}">`
            : `<${type} part="${part}">`;
        return `${tag}${body}</${type}>`;
    },
    /**
     * Custom Marked renderer to remove wrapping `<p>` element around list item content.
     * @param text The element text content.
     * @returns The list item element to render.
     */
    listitem(text) {
        const unwrappedText = text
            .replace(/^<p[^>]*>/, '')
            .replace(/<\/p>\n?$/, '');
        const withClosedElement = completeUnclosedElement(unwrappedText);
        return `<li part="answer-list-item">${withClosedElement}</li>`;
    },
    paragraph(text) {
        return `<p part="answer-paragraph">${text}</p>`;
    },
    strong(text) {
        return `<strong part="answer-strong">${text}</strong>`;
    },
    /**
     * Custom Marked renderer to wrap `<table>` element in a scrolling container.
     * @param header The table header content.
     * @param body The table body content.
     * @returns The element to render.
     */
    table(header, body) {
        return `<div part="answer-table-container" class="scrollable-table"><table part="answer-table"><thead>${header}</thead><tbody>${body}</tbody></table></div>`;
    },
    tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const part = flags.header ? 'answer-table-header' : 'answer-table-content';
        const tag = flags.align
            ? `<${type} part="${part}" align="${flags.align}">`
            : `<${type} part="${part}">`;
        return `${tag}${content}</${type}>`;
    },
    /**
     * Custom Marked renderer to complete unclosed inline elements such as bold, italic, and code.
     * @param text The text content.
     * @returns The corrected text content.
     */
    text(text) {
        return completeUnclosedElement(text);
    },
};
const transformMarkdownToHtml = (text) => {
    return marked_umd.exports.marked.use({ renderer: customRenderer }).parse(text);
};

const GeneratedMarkdownContent = (props) => {
    var _a;
    const answerAsHtml = utils.DOMPurify.sanitize(transformMarkdownToHtml((_a = props.answer) !== null && _a !== void 0 ? _a : ''), { ADD_ATTR: ['part'] });
    return (index.h("div", { part: "generated-text", class: `mb-0 text-on-background ${props.isStreaming ? 'cursor' : ''}`, innerHTML: answerAsHtml }));
};

const GeneratedTextContent = (props) => {
    return (index.h("p", { part: "generated-text", class: `mb-0 text-on-background whitespace-pre-wrap ${props.isStreaming ? 'cursor' : ''}` }, props.answer));
};

const GeneratedContentContainer = (props, children) => {
    return (index.h("div", { part: "generated-container", class: "mt-6" },
        props.answerContentFormat === 'text/markdown' ? (index.h(GeneratedMarkdownContent, { answer: props.answer, isStreaming: props.isStreaming })) : (index.h(GeneratedTextContent, { answer: props.answer, isStreaming: props.isStreaming })),
        index.h("div", { class: "footer mt-6" }, children)));
};

const BulletsIcon = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <line x1="7.5" y1="3" x2="13.5" y2="3" stroke="currentColor" stroke-linecap="round" />
  <line x1="7.5" y1="13" x2="13.5" y2="13" stroke="currentColor" stroke-linecap="round" />
  <line x1="7.5" y1="8" x2="13.5" y2="8" stroke="currentColor" stroke-linecap="round" />
  <circle cx="3.5" cy="3" r="1.5" fill="currentColor" />
  <circle cx="3.5" cy="8" r="1.5" fill="currentColor" />
  <circle cx="3.5" cy="13" r="1.5" fill="currentColor" />
</svg>`;

const IdeaIcon = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7 13.5C7 14.0523 7.44772 14.5 8 14.5C8.55228 14.5 9 14.0523 9 13.5" stroke="currentColor"
    stroke-linecap="round" stroke-linejoin="round" />
  <path
    d="M11.5 7.05C11.5 8.20833 10.9538 9.23537 10.109 9.88341C9.82908 10.0981 9.53089 10.3663 9.31281 10.7201L9.26859 10.7918C8.99723 11.232 8.51709 11.5 8 11.5C7.48291 11.5 7.00277 11.232 6.73141 10.7918L6.68719 10.7201C6.46911 10.3663 6.17091 10.0981 5.89101 9.88341C5.04624 9.23537 4.5 8.20833 4.5 7.05C4.5 5.08351 6.07284 3.5 8 3.5C9.92716 3.5 11.5 5.08351 11.5 7.05Z"
    stroke="currentColor" />
  <path d="M2.5 7.5L2 7.5" stroke="currentColor" stroke-linecap="round" />
  <path d="M3.5 3.5L3.00001 3" stroke="currentColor" stroke-linecap="round" />
  <path d="M14 7.5L13.5 7.5" stroke="currentColor" stroke-linecap="round" />
  <path d="M13 3L12.5 3.5" stroke="currentColor" stroke-linecap="round" />
  <path d="M8 2L8 1.5" stroke="currentColor" stroke-linecap="round" />
</svg>`;

const StepsIcon = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <line x1="8.5" y1="3" x2="14.5" y2="3" stroke="currentColor" stroke-linecap="round" />
  <path d="M2 2.77548L3.37137 4.16667L6 1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" />
  <line x1="8.5" y1="13" x2="14.5" y2="13" stroke="currentColor" stroke-linecap="round" />
  <line x1="8.5" y1="8" x2="14.5" y2="8" stroke="currentColor" stroke-linecap="round" />
  <path d="M2 12.7755L3.37137 14.1667L6 11.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" />
  <path d="M2 7.77548L3.37137 9.16667L6 6.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" />
</svg>`;

const TextIcon = `<svg width="15" height="16" viewBox="0 0 15 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <line x1="1.5" y1="2.75" x2="13.5" y2="2.75" stroke="currentColor" stroke-linecap="round" />
    <path d="M1.5 12.75H7.5" stroke="currentColor" stroke-linecap="round" />
    <line x1="1.5" y1="7.75" x2="13.5" y2="7.75" stroke="currentColor" stroke-linecap="round" />
</svg>`;

const options = [
    {
        value: 'default',
        icon: TextIcon,
        titleKey: 'auto',
        tooltipKey: 'auto-tooltip',
    },
    {
        value: 'step',
        icon: StepsIcon,
        titleKey: 'steps',
        tooltipKey: 'steps-tooltip',
    },
    {
        value: 'bullet',
        icon: BulletsIcon,
        titleKey: 'bullets',
        tooltipKey: 'bullets-tooltip',
    },
    {
        titleKey: 'summary',
        value: 'concise',
        icon: IdeaIcon,
        tooltipKey: 'summary',
    },
];
const RephraseButtons = (props) => {
    const { i18n } = props;
    return (index.h("div", { part: "rephrase-buttons", class: "shrink-0" },
        index.h("p", { part: "rephrase-label", class: "mb-2 text-neutral-dark shrink-0" }, i18n.t('rephrase')),
        index.h("div", { part: "rephrase-buttons-container", class: "flex flex-wrap gap-2 ml-auto border border-solid rounded-md p-1" }, options.map((option) => {
            const isActive = props.answerStyle === option.value;
            return (index.h(button.Button, { title: i18n.t(option.tooltipKey), part: "rephrase-button", style: "text-transparent", class: `flex items-center rounded ${isActive ? 'active' : ''}`, onClick: () => {
                    props.onChange(option.value);
                }, ariaPressed: String(isActive) },
                index.h("div", { class: "icon-container text-neutral-dark h-full mx-auto shrink-0 relative" },
                    index.h("atomic-icon", { icon: option.icon })),
                index.h("div", { part: "rephrase-button-label", class: "hidden text-neutral-dark" }, i18n.t(option.titleKey))));
        }))));
};

const RetryPrompt = (props) => (index.h("div", { part: "retry-container", class: "mt-4" },
    index.h("div", { class: "mx-auto text-center text-neutral-dark" }, props.message),
    index.h(button.Button, { class: "block px-4 py-2 mt-4 mx-auto", style: "outline-primary", onClick: props.onClick }, props.buttonLabel)));

const ShowButton = (props) => (index.h(button.Button, { style: "text-primary", part: "answer-show-button", class: "hidden items-center hover:bg-transparent", onClick: () => props.onClick() },
    index.h("div", { class: "font-light text-base" }, props.isCollapsed
        ? props.i18n.t('show-more')
        : props.i18n.t('show-less')),
    index.h("atomic-icon", { part: "answer-show-icon", class: "w-3.5 ml-2", icon: props.isCollapsed ? arrowBottomRounded.ArrowBottomIcon : arrowTopRounded.ArrowUp })));

const SourceCitations = (props, children) => props.isVisible ? (index.h("div", { class: "source-citations" },
    index.h("p", { part: "citations-label", class: "mb-2 text-neutral-dark shrink-0" }, props.label),
    index.h("ol", { class: "list-none citations-container gap-2 flex items-center flex-wrap" }, children))) : null;

class GeneratedAnswerCommon {
    constructor(props) {
        this.props = props;
        this.storage = new localStorageUtils.SafeStorage();
        this.contentClasses = 'mt-0 mb-4 border border-neutral shadow-lg p-6 bg-background rounded-lg p-6 text-on-background';
        this._data = this.readStoredData();
    }
    insertFeedbackModal() {
        this.modalRef = document.createElement('atomic-generated-answer-feedback-modal');
        this.modalRef.generatedAnswer = this.props.getGeneratedAnswer();
        this.props.host.insertAdjacentElement('beforebegin', this.modalRef);
    }
    readStoredData() {
        const { withToggle } = this.props;
        const storedData = this.storage.getParsedJSON(localStorageUtils.StorageItems.GENERATED_ANSWER_DATA, { isVisible: true });
        // This check ensures that the answer is visible when the toggle is hidden and visible is set to false in the local storage.
        return { isVisible: (withToggle && storedData.isVisible) || !withToggle };
    }
    writeStoredData(data) {
        this.storage.setJSON(localStorageUtils.StorageItems.GENERATED_ANSWER_DATA, data);
    }
    get data() {
        return this._data;
    }
    set data(newData) {
        this._data = newData;
    }
    getGeneratedAnswerStatus() {
        var _a, _b, _c, _d, _e;
        const isHidden = !((_a = this.props.getGeneratedAnswerState()) === null || _a === void 0 ? void 0 : _a.isVisible);
        const isGenerating = !!((_b = this.props.getGeneratedAnswerState()) === null || _b === void 0 ? void 0 : _b.isStreaming);
        const hasAnswer = !!((_c = this.props.getGeneratedAnswerState()) === null || _c === void 0 ? void 0 : _c.answer);
        const hasError = !!((_d = this.props.getGeneratedAnswerState()) === null || _d === void 0 ? void 0 : _d.error);
        if (isHidden) {
            return this.props.getBindings().i18n.t('generated-answer-hidden');
        }
        if (isGenerating) {
            return this.props.getBindings().i18n.t('generating-answer');
        }
        if (hasError) {
            return this.props.getBindings().i18n.t('answer-could-not-be-generated');
        }
        if (hasAnswer) {
            return this.props.getBindings().i18n.t('answer-generated', {
                answer: (_e = this.props.getGeneratedAnswerState()) === null || _e === void 0 ? void 0 : _e.answer,
            });
        }
        return '';
    }
    get hasRetryableError() {
        var _a, _b, _c;
        return (!((_a = this.props.getSearchStatusState()) === null || _a === void 0 ? void 0 : _a.hasError) &&
            ((_c = (_b = this.props.getGeneratedAnswerState()) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.isRetryable));
    }
    get shouldBeHidden() {
        var _a;
        const { answer, citations } = (_a = this.props.getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        return (answer === undefined && !(citations === null || citations === void 0 ? void 0 : citations.length) && !this.hasRetryableError);
    }
    get isAnswerVisible() {
        var _a;
        return (_a = this.props.getGeneratedAnswerState()) === null || _a === void 0 ? void 0 : _a.isVisible;
    }
    get toggleTooltip() {
        const key = this.isAnswerVisible
            ? 'generated-answer-toggle-on'
            : 'generated-answer-toggle-off';
        return this.props.getBindings().i18n.t(key);
    }
    get hasClipboard() {
        var _a;
        return !!((_a = navigator === null || navigator === void 0 ? void 0 : navigator.clipboard) === null || _a === void 0 ? void 0 : _a.writeText);
    }
    get copyToClipboardTooltip() {
        if (this.props.getCopyError()) {
            return this.props.getBindings().i18n.t('failed-to-copy-generated-answer');
        }
        return !this.props.getCopied()
            ? this.props.getBindings().i18n.t('copy-generated-answer')
            : this.props.getBindings().i18n.t('generated-answer-copied');
    }
    async copyToClipboard(answer) {
        var _a;
        try {
            await navigator.clipboard.writeText(answer);
            this.props.setCopied(true);
            (_a = this.props.getGeneratedAnswer()) === null || _a === void 0 ? void 0 : _a.logCopyToClipboard();
        }
        catch (error) {
            this.props.setCopyError(true);
            this.props
                .getBindings()
                .engine.logger.error(`Failed to copy to clipboard: ${error}`);
        }
        setTimeout(() => {
            this.props.setCopied(false);
            this.props.setCopyError(false);
        }, 2000);
    }
    clickOnShowButton() {
        var _a, _b, _c;
        if ((_a = this.props.getGeneratedAnswerState()) === null || _a === void 0 ? void 0 : _a.expanded) {
            (_b = this.props.getGeneratedAnswer()) === null || _b === void 0 ? void 0 : _b.collapse();
        }
        else {
            (_c = this.props.getGeneratedAnswer()) === null || _c === void 0 ? void 0 : _c.expand();
        }
    }
    getCitation(citation) {
        const { title } = citation;
        const { i18n } = this.props.getBindings();
        return title.trim() !== ''
            ? citation
            : { ...citation, title: i18n.t('no-title') };
    }
    renderCitations() {
        var _a, _b;
        const { getGeneratedAnswerState, buildInteractiveCitation, getGeneratedAnswer, } = this.props;
        const { citations } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        const { logCitationHover } = (_b = getGeneratedAnswer()) !== null && _b !== void 0 ? _b : {};
        return citations === null || citations === void 0 ? void 0 : citations.map((citation, index$1) => {
            const interactiveCitation = buildInteractiveCitation({
                options: {
                    citation,
                },
            });
            return (index.h("li", { key: citation.id, class: "max-w-full" },
                index.h("atomic-citation", { citation: this.getCitation(citation), index: index$1, sendHoverEndEvent: (citationHoverTimeMs) => {
                        logCitationHover === null || logCitationHover === void 0 ? void 0 : logCitationHover(citation.id, citationHoverTimeMs);
                    }, interactiveCitation: interactiveCitation, exportparts: "citation,citation-popover" })));
        });
    }
    renderFeedbackAndCopyButtons() {
        var _a;
        const { getGeneratedAnswerState, getBindings, getGeneratedAnswer, getCopied, getCopyError, } = this.props;
        const { i18n } = getBindings();
        const { liked, disliked, answer, isStreaming } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        const containerClasses = [
            'feedback-buttons',
            'flex',
            'h-9',
            'absolute',
            'top-6',
            'shrink-0',
            'gap-2',
            this.props.withToggle ? 'right-20' : 'right-6',
        ].join(' ');
        if (isStreaming) {
            return null;
        }
        return (index.h("div", { class: containerClasses },
            index.h(FeedbackButton, { title: i18n.t('this-answer-was-helpful'), variant: "like", active: !!liked, onClick: () => { var _a; return (_a = getGeneratedAnswer()) === null || _a === void 0 ? void 0 : _a.like(); } }),
            index.h(FeedbackButton, { title: i18n.t('this-answer-was-not-helpful'), variant: "dislike", active: !!disliked, onClick: () => this.clickDislike() }),
            this.hasClipboard ? (index.h(CopyButton, { title: this.copyToClipboardTooltip, isCopied: getCopied(), error: getCopyError(), onClick: async () => {
                    if (answer) {
                        await this.copyToClipboard(answer);
                    }
                } })) : null));
    }
    clickDislike() {
        var _a, _b;
        if (this.modalRef &&
            !((_a = this.props.getGeneratedAnswerState()) === null || _a === void 0 ? void 0 : _a.feedbackSubmitted)) {
            this.modalRef.isOpen = true;
        }
        (_b = this.props.getGeneratedAnswer()) === null || _b === void 0 ? void 0 : _b.dislike();
    }
    onChangeAnswerStyle(answerStyle) {
        var _a, _b, _c;
        if (((_a = this.props.getGeneratedAnswerState()) === null || _a === void 0 ? void 0 : _a.responseFormat.answerStyle) !==
            answerStyle) {
            (_b = this.props.getGeneratedAnswer()) === null || _b === void 0 ? void 0 : _b.rephrase({
                ...(_c = this.props.getGeneratedAnswerState()) === null || _c === void 0 ? void 0 : _c.responseFormat,
                answerStyle,
            });
        }
    }
    renderRephraseButtons() {
        var _a;
        const { getGeneratedAnswerState, getBindings } = this.props;
        const { i18n } = getBindings();
        const { isStreaming, responseFormat } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        const { answerStyle } = responseFormat !== null && responseFormat !== void 0 ? responseFormat : {};
        if (isStreaming) {
            return null;
        }
        return (index.h(RephraseButtons, { answerStyle: answerStyle !== null && answerStyle !== void 0 ? answerStyle : 'default', i18n: i18n, onChange: (answerStyle) => this.onChangeAnswerStyle(answerStyle) }));
    }
    renderDisclaimer() {
        var _a;
        const { getGeneratedAnswerState, getBindings } = this.props;
        const { i18n } = getBindings();
        const { isStreaming } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        if (isStreaming) {
            return null;
        }
        return (index.h("div", { class: "text-neutral-dark text-xs" },
            index.h("slot", { name: "disclaimer", slot: "disclaimer" }, i18n.t('generated-answer-disclaimer'))));
    }
    renderShowButton() {
        var _a;
        const { getGeneratedAnswerState, getBindings, collapsible } = this.props;
        const { i18n } = getBindings();
        const { expanded, isStreaming } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        const canRender = collapsible && !isStreaming;
        if (!canRender) {
            return null;
        }
        return (index.h(ShowButton, { i18n: i18n, onClick: () => this.clickOnShowButton(), isCollapsed: !expanded }));
    }
    renderGeneratingAnswerLabel() {
        var _a;
        const { getGeneratedAnswerState, getBindings, collapsible } = this.props;
        const { i18n } = getBindings();
        const { isStreaming } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        const canRender = collapsible && isStreaming;
        if (!canRender) {
            return null;
        }
        return (index.h("div", { part: "is-generating", class: "hidden text-primary font-light text-base" },
            i18n.t('generating-answer'),
            "..."));
    }
    renderContent() {
        var _a;
        const { getGeneratedAnswerState, getBindings, getGeneratedAnswer } = this.props;
        const { i18n } = getBindings();
        const { isStreaming, answer, citations, answerContentFormat } = (_a = getGeneratedAnswerState()) !== null && _a !== void 0 ? _a : {};
        return (index.h("div", { part: "generated-content" },
            index.h("div", { class: "flex items-center" },
                index.h(heading.Heading, { level: 0, part: "header-label", class: "text-bg-primary font-medium inline-block rounded-md py-2 px-2.5" }, i18n.t('generated-answer-title')),
                index.h("div", { class: "flex h-9 items-center ml-auto" },
                    index.h(Switch, { part: "toggle", checked: this.isAnswerVisible, onToggle: (checked) => {
                            var _a, _b;
                            checked
                                ? (_a = getGeneratedAnswer()) === null || _a === void 0 ? void 0 : _a.show()
                                : (_b = getGeneratedAnswer()) === null || _b === void 0 ? void 0 : _b.hide();
                        }, ariaLabel: i18n.t('generated-answer-title'), title: this.toggleTooltip, withToggle: this.props.withToggle }))),
            this.hasRetryableError && this.isAnswerVisible ? (index.h(RetryPrompt, { onClick: () => { var _a; return (_a = getGeneratedAnswer()) === null || _a === void 0 ? void 0 : _a.retry(); }, buttonLabel: i18n.t('retry'), message: i18n.t('retry-stream-message') })) : null,
            !this.hasRetryableError && this.isAnswerVisible ? (index.h(GeneratedContentContainer, { answer: answer, answerContentFormat: answerContentFormat, isStreaming: !!isStreaming },
                this.renderFeedbackAndCopyButtons(),
                index.h(SourceCitations, { label: i18n.t('citations'), isVisible: !!(citations === null || citations === void 0 ? void 0 : citations.length) }, this.renderCitations()),
                this.renderRephraseButtons())) : null,
            !this.hasRetryableError && this.isAnswerVisible && (index.h("div", { part: "generated-answer-footer", class: "flex justify-end mt-6" },
                this.renderGeneratingAnswerLabel(),
                this.renderShowButton(),
                this.renderDisclaimer()))));
    }
    render() {
        if (this.shouldBeHidden) {
            return null;
        }
        return (index.h("div", null,
            index.h("aside", { class: `mx-auto ${this.contentClasses}`, part: "container" },
                index.h("article", null, this.renderContent()))));
    }
}

exports.GeneratedAnswerCommon = GeneratedAnswerCommon;

//# sourceMappingURL=generated-answer-common-291b7349.js.map