{"version":3,"names":["getTemplateNodeType","node","isResultSectionNode","isVisualNode","isElementNode","tagName","toLowerCase","tableElementTagName","groupNodesByType","nodes","aggregate","Array","from","ResultTemplateCommon","constructor","host","setError","validParents","allowEmpty","this","matchConditions","validateTemplate","hasValidParent","map","p","toUpperCase","includes","_a","parentElement","nodeName","Error","join","template","querySelector","innerHTML","trim","content","console","warn","section","sectionNodes","other","otherNodes","childNodes","length","getTemplate","conditions","error","concat","getTemplateElement","priority","renderIfError","h","element","makeMatchConditions","mustMatch","mustNotMatch","field","push","ResultTemplatesHelpers","fieldMustMatch","fieldMustNotMatch","makeDefinedConditions","ifDefined","ifNotDefined","fieldNames","split","fieldsMustBeDefined","fieldsMustNotBeDefined"],"sources":["src/components/common/result-templates/result-template-common.tsx"],"sourcesContent":["import {\r\n  ResultTemplate,\r\n  ResultTemplateCondition,\r\n  ResultTemplatesHelpers,\r\n} from '@coveo/headless';\r\nimport {h} from '@stencil/core';\r\nimport {aggregate, isElementNode, isVisualNode} from '../../../utils/utils';\r\nimport {tableElementTagName} from '../../search/atomic-table-result/table-element-utils';\r\nimport {isResultSectionNode} from '../layout/sections';\r\n\r\nexport type TemplateContent = DocumentFragment;\r\n\r\ninterface ResultTemplateCommonProps {\r\n  allowEmpty?: boolean;\r\n  host: HTMLDivElement;\r\n  validParents: string[];\r\n  setError: (error: Error) => void;\r\n}\r\n\r\ntype TemplateNodeType =\r\n  | 'section'\r\n  | 'metadata'\r\n  | 'table-column-definition'\r\n  | 'other';\r\n\r\nexport function getTemplateNodeType(node: Node): TemplateNodeType {\r\n  if (isResultSectionNode(node)) {\r\n    return 'section';\r\n  }\r\n  if (!isVisualNode(node)) {\r\n    return 'metadata';\r\n  }\r\n  if (\r\n    isElementNode(node) &&\r\n    node.tagName.toLowerCase() === tableElementTagName\r\n  ) {\r\n    return 'table-column-definition';\r\n  }\r\n  return 'other';\r\n}\r\n\r\nfunction groupNodesByType(nodes: NodeList) {\r\n  return aggregate(Array.from(nodes), (node) => getTemplateNodeType(node));\r\n}\r\n\r\nexport class ResultTemplateCommon {\r\n  private host: HTMLDivElement;\r\n  public matchConditions: ResultTemplateCondition[] = [];\r\n\r\n  constructor({\r\n    host,\r\n    setError,\r\n    validParents,\r\n    allowEmpty = false,\r\n  }: ResultTemplateCommonProps) {\r\n    this.host = host;\r\n    this.validateTemplate(host, setError, validParents, allowEmpty);\r\n  }\r\n\r\n  validateTemplate(\r\n    host: HTMLDivElement,\r\n    setError: (error: Error) => void,\r\n    validParents: string[],\r\n    allowEmpty = true\r\n  ) {\r\n    const hasValidParent = validParents\r\n      .map((p) => p.toUpperCase())\r\n      .includes(host.parentElement?.nodeName || '');\r\n    const tagName = host.nodeName.toLowerCase();\r\n\r\n    if (!hasValidParent) {\r\n      setError(\r\n        new Error(\r\n          `The \"${tagName}\" component has to be the child of one of the following: ${validParents\r\n            .map((p) => `\"${p.toLowerCase()}\"`)\r\n            .join(', ')}.`\r\n        )\r\n      );\r\n      return;\r\n    }\r\n\r\n    const template = host.querySelector('template');\r\n    if (!template) {\r\n      setError(\r\n        new Error(\r\n          `The \"${tagName}\" component has to contain a \"template\" element as a child.`\r\n        )\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (!allowEmpty && !template.innerHTML.trim()) {\r\n      setError(\r\n        new Error(`The \"template\" tag inside \"${tagName}\" cannot be empty.`)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (template.content.querySelector('script')) {\r\n      console.warn(\r\n        'Any \"script\" tags defined inside of \"template\" elements are not supported and will not be executed when the results are rendered.',\r\n        host\r\n      );\r\n    }\r\n\r\n    const {section: sectionNodes, other: otherNodes} = groupNodesByType(\r\n      template.content.childNodes\r\n    );\r\n    if (sectionNodes?.length && otherNodes?.length) {\r\n      console.warn(\r\n        'Result templates should only contain section elements or non-section elements. Future updates could unpredictably affect this result template.',\r\n        host,\r\n        {sectionNodes, otherNodes}\r\n      );\r\n    }\r\n  }\r\n\r\n  getTemplate(\r\n    conditions: ResultTemplateCondition[],\r\n    error: Error\r\n  ): ResultTemplate<TemplateContent> | null {\r\n    if (error) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      conditions: conditions.concat(this.matchConditions),\r\n      content: getTemplateElement(this.host).content!,\r\n      priority: 1,\r\n    };\r\n  }\r\n\r\n  renderIfError(error: Error) {\r\n    if (error) {\r\n      return (\r\n        <atomic-component-error\r\n          element={this.host}\r\n          error={error}\r\n        ></atomic-component-error>\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction getTemplateElement(host: HTMLElement) {\r\n  return host.querySelector('template')!;\r\n}\r\n\r\nexport function makeMatchConditions(\r\n  mustMatch: Record<string, string[]>,\r\n  mustNotMatch: Record<string, string[]>\r\n): ResultTemplateCondition[] {\r\n  const conditions: ResultTemplateCondition[] = [];\r\n  for (const field in mustMatch) {\r\n    conditions.push(\r\n      ResultTemplatesHelpers.fieldMustMatch(field, mustMatch[field])\r\n    );\r\n  }\r\n\r\n  for (const field in mustNotMatch) {\r\n    conditions.push(\r\n      ResultTemplatesHelpers.fieldMustNotMatch(field, mustNotMatch[field])\r\n    );\r\n  }\r\n  return conditions;\r\n}\r\n\r\nexport function makeDefinedConditions(\r\n  ifDefined?: string,\r\n  ifNotDefined?: string\r\n): ResultTemplateCondition[] {\r\n  const conditions: ResultTemplateCondition[] = [];\r\n  if (ifDefined) {\r\n    const fieldNames = ifDefined.split(',');\r\n    conditions.push(ResultTemplatesHelpers.fieldsMustBeDefined(fieldNames));\r\n  }\r\n\r\n  if (ifNotDefined) {\r\n    const fieldNames = ifNotDefined.split(',');\r\n    conditions.push(ResultTemplatesHelpers.fieldsMustNotBeDefined(fieldNames));\r\n  }\r\n  return conditions;\r\n}\r\n"],"mappings":"2MAyBgBA,EAAoBC,GAClC,GAAIC,EAAoBD,GAAO,CAC7B,MAAO,S,CAET,IAAKE,EAAaF,GAAO,CACvB,MAAO,U,CAET,GACEG,EAAcH,IACdA,EAAKI,QAAQC,gBAAkBC,EAC/B,CACA,MAAO,yB,CAET,MAAO,OACT,CAEA,SAASC,EAAiBC,GACxB,OAAOC,EAAUC,MAAMC,KAAKH,IAASR,GAASD,EAAoBC,IACpE,C,MAEaY,EAIX,WAAAC,EAAYC,KACVA,EAAIC,SACJA,EAAQC,aACRA,EAAYC,WACZA,EAAa,QANRC,KAAAC,gBAA6C,GAQlDD,KAAKJ,KAAOA,EACZI,KAAKE,iBAAiBN,EAAMC,EAAUC,EAAcC,E,CAGtD,gBAAAG,CACEN,EACAC,EACAC,EACAC,EAAa,M,MAEb,MAAMI,EAAiBL,EACpBM,KAAKC,GAAMA,EAAEC,gBACbC,WAASC,EAAAZ,EAAKa,iBAAa,MAAAD,SAAA,SAAAA,EAAEE,WAAY,IAC5C,MAAMxB,EAAUU,EAAKc,SAASvB,cAE9B,IAAKgB,EAAgB,CACnBN,EACE,IAAIc,MACF,QAAQzB,6DAAmEY,EACxEM,KAAKC,GAAM,IAAIA,EAAElB,mBACjByB,KAAK,WAGZ,M,CAGF,MAAMC,EAAWjB,EAAKkB,cAAc,YACpC,IAAKD,EAAU,CACbhB,EACE,IAAIc,MACF,QAAQzB,iEAGZ,M,CAGF,IAAKa,IAAec,EAASE,UAAUC,OAAQ,CAC7CnB,EACE,IAAIc,MAAM,8BAA8BzB,wBAE1C,M,CAGF,GAAI2B,EAASI,QAAQH,cAAc,UAAW,CAC5CI,QAAQC,KACN,oIACAvB,E,CAIJ,MAAOwB,QAASC,EAAcC,MAAOC,GAAclC,EACjDwB,EAASI,QAAQO,YAEnB,IAAIH,IAAY,MAAZA,SAAY,SAAZA,EAAcI,UAAUF,IAAU,MAAVA,SAAU,SAAVA,EAAYE,QAAQ,CAC9CP,QAAQC,KACN,iJACAvB,EACA,CAACyB,eAAcE,c,EAKrB,WAAAG,CACEC,EACAC,GAEA,GAAIA,EAAO,CACT,OAAO,I,CAGT,MAAO,CACLD,WAAYA,EAAWE,OAAO7B,KAAKC,iBACnCgB,QAASa,EAAmB9B,KAAKJ,MAAMqB,QACvCc,SAAU,E,CAId,aAAAC,CAAcJ,GACZ,GAAIA,EAAO,CACT,OACEK,EAAA,0BACEC,QAASlC,KAAKJ,KACdgC,MAAOA,G,GAOjB,SAASE,EAAmBlC,GAC1B,OAAOA,EAAKkB,cAAc,WAC5B,C,SAEgBqB,EACdC,EACAC,GAEA,MAAMV,EAAwC,GAC9C,IAAK,MAAMW,KAASF,EAAW,CAC7BT,EAAWY,KACTC,EAAuBC,eAAeH,EAAOF,EAAUE,I,CAI3D,IAAK,MAAMA,KAASD,EAAc,CAChCV,EAAWY,KACTC,EAAuBE,kBAAkBJ,EAAOD,EAAaC,I,CAGjE,OAAOX,CACT,C,SAEgBgB,EACdC,EACAC,GAEA,MAAMlB,EAAwC,GAC9C,GAAIiB,EAAW,CACb,MAAME,EAAaF,EAAUG,MAAM,KACnCpB,EAAWY,KAAKC,EAAuBQ,oBAAoBF,G,CAG7D,GAAID,EAAc,CAChB,MAAMC,EAAaD,EAAaE,MAAM,KACtCpB,EAAWY,KAAKC,EAAuBS,uBAAuBH,G,CAEhE,OAAOnB,CACT,Q"}