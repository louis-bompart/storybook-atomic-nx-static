{"version":3,"names":["shouldDisplayInputForFacetRange","facetRange","hasInput","hasInputRange","searchStatusState","facetValues","hasResults","onlyValuesWithResultsOrActive","filter","value","numberOfResults","state","length","sortFacetVisibility","facetElements","facetInfoMap","visibleFacets","invisibleFacets","forEach","facet","facetId","isHidden","push","collapseFacetsAfter","facets","visibleFacetsCount","index","isCollapsed","isAutomaticFacetGenerator","element","tagName","isPseudoFacet","el","getFacetsInChildren","parent","Array","from","children","child","getAutomaticFacetGenerator","find","get2DMatrix","xSize","ySize","fill","map","findIndiceOfParent","parents","i","_a","contains","triageFacetsByParents","sortedFacets","indice"],"sources":["src/components/common/facets/facet-common.tsx"],"sourcesContent":["import {i18n} from 'i18next';\nimport {FacetValue, SearchStatusState} from '../types';\n\nexport interface FacetValueProps {\n  i18n: i18n;\n  displayValue: string;\n  numberOfResults: number;\n  isSelected: boolean;\n  onClick(): void;\n  searchQuery?: string;\n  class?: string;\n  part?: string;\n  additionalPart?: string;\n  buttonRef?: (element?: HTMLButtonElement) => void;\n}\n\nexport function shouldDisplayInputForFacetRange(facetRange: {\n  hasInput: boolean;\n  hasInputRange: boolean;\n  searchStatusState: SearchStatusState;\n  facetValues: Pick<FacetValue, 'numberOfResults' | 'state'>[];\n}) {\n  const {hasInput, hasInputRange, searchStatusState, facetValues} = facetRange;\n  if (!hasInput) {\n    return false;\n  }\n\n  if (hasInputRange) {\n    return true;\n  }\n\n  if (!searchStatusState.hasResults) {\n    return false;\n  }\n\n  const onlyValuesWithResultsOrActive =\n    facetValues.filter(\n      (value) => value.numberOfResults || value.state !== 'idle'\n    ) || [];\n\n  if (!onlyValuesWithResultsOrActive.length) {\n    return false;\n  }\n\n  return true;\n}\n\nexport type BaseFacetElement = HTMLElement & {\n  facetId: string;\n  isCollapsed: boolean;\n};\n\nexport function sortFacetVisibility(\n  facetElements: BaseFacetElement[],\n  facetInfoMap: Record<string, {isHidden: () => boolean}>\n) {\n  const visibleFacets: BaseFacetElement[] = [];\n  const invisibleFacets: BaseFacetElement[] = [];\n\n  facetElements.forEach((facet) => {\n    if (facetInfoMap[facet.facetId] && facetInfoMap[facet.facetId].isHidden()) {\n      invisibleFacets.push(facet);\n    } else {\n      visibleFacets.push(facet);\n    }\n  });\n\n  return {visibleFacets, invisibleFacets};\n}\n\nexport function collapseFacetsAfter(\n  facets: BaseFacetElement[],\n  visibleFacetsCount: number\n) {\n  if (visibleFacetsCount === -1) {\n    return;\n  }\n\n  facets.forEach((facet, index) => {\n    facet.isCollapsed = index + 1 > visibleFacetsCount;\n  });\n}\n\nexport function isAutomaticFacetGenerator(\n  element: HTMLElement\n): element is HTMLAtomicAutomaticFacetGeneratorElement {\n  return element.tagName === 'ATOMIC-AUTOMATIC-FACET-GENERATOR';\n}\n\nfunction isPseudoFacet(el: Element): el is BaseFacetElement {\n  return 'facetId' in el;\n}\n\nexport function getFacetsInChildren(parent: HTMLElement): BaseFacetElement[] {\n  const facets = Array.from(parent.children).filter((child) =>\n    isPseudoFacet(child)\n  ) as BaseFacetElement[];\n\n  return facets;\n}\nexport function getAutomaticFacetGenerator(\n  parent: HTMLElement\n): HTMLAtomicAutomaticFacetGeneratorElement | undefined {\n  return (Array.from(parent.children) as HTMLElement[]).find(\n    isAutomaticFacetGenerator\n  );\n}\n\nconst get2DMatrix = (xSize: number, ySize: number = 0) =>\n  new Array(xSize).fill(null).map(() => new Array(ySize));\n\nfunction findIndiceOfParent(\n  facet: BaseFacetElement,\n  parents: (HTMLElement | null)[]\n) {\n  for (let i = 0; i < parents.length; i++) {\n    if (parents[i]?.contains(facet)) {\n      return i;\n    }\n  }\n  return parents.length;\n}\n\n/**\n * Triage elements by their parents.\n * @param facets Facet Elements\n * @param parents Elements that may contains the facets\n * @returns an array in the same order as the parents, containing the facets that are contained by the corresponding parent.\n * The last element of the array contains the facets that are not contained by any of the parents.\n */\nexport function triageFacetsByParents(\n  facets: BaseFacetElement[],\n  ...parents: (HTMLElement | null)[]\n) {\n  const sortedFacets: BaseFacetElement[][] = get2DMatrix(parents.length + 1);\n  for (const facet of facets) {\n    const indice = findIndiceOfParent(facet, parents);\n    sortedFacets[indice].push(facet);\n  }\n  return sortedFacets;\n}\n"],"mappings":"SAgBgBA,EAAgCC,GAM9C,MAAMC,SAACA,EAAQC,cAAEA,EAAaC,kBAAEA,EAAiBC,YAAEA,GAAeJ,EAClE,IAAKC,EAAU,CACb,OAAO,K,CAGT,GAAIC,EAAe,CACjB,OAAO,I,CAGT,IAAKC,EAAkBE,WAAY,CACjC,OAAO,K,CAGT,MAAMC,EACJF,EAAYG,QACTC,GAAUA,EAAMC,iBAAmBD,EAAME,QAAU,UACjD,GAEP,IAAKJ,EAA8BK,OAAQ,CACzC,OAAO,K,CAGT,OAAO,IACT,C,SAOgBC,EACdC,EACAC,GAEA,MAAMC,EAAoC,GAC1C,MAAMC,EAAsC,GAE5CH,EAAcI,SAASC,IACrB,GAAIJ,EAAaI,EAAMC,UAAYL,EAAaI,EAAMC,SAASC,WAAY,CACzEJ,EAAgBK,KAAKH,E,KAChB,CACLH,EAAcM,KAAKH,E,KAIvB,MAAO,CAACH,gBAAeC,kBACzB,C,SAEgBM,EACdC,EACAC,GAEA,GAAIA,KAAwB,EAAG,CAC7B,M,CAGFD,EAAON,SAAQ,CAACC,EAAOO,KACrBP,EAAMQ,YAAcD,EAAQ,EAAID,CAAkB,GAEtD,C,SAEgBG,EACdC,GAEA,OAAOA,EAAQC,UAAY,kCAC7B,CAEA,SAASC,EAAcC,GACrB,MAAO,YAAaA,CACtB,C,SAEgBC,EAAoBC,GAClC,MAAMV,EAASW,MAAMC,KAAKF,EAAOG,UAAU7B,QAAQ8B,GACjDP,EAAcO,KAGhB,OAAOd,CACT,C,SACgBe,EACdL,GAEA,OAAQC,MAAMC,KAAKF,EAAOG,UAA4BG,KACpDZ,EAEJ,CAEA,MAAMa,EAAc,CAACC,EAAeC,EAAgB,IAClD,IAAIR,MAAMO,GAAOE,KAAK,MAAMC,KAAI,IAAM,IAAIV,MAAMQ,KAElD,SAASG,EACP3B,EACA4B,G,MAEA,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQnC,OAAQoC,IAAK,CACvC,IAAIC,EAAAF,EAAQC,MAAE,MAAAC,SAAA,SAAAA,EAAEC,SAAS/B,GAAQ,CAC/B,OAAO6B,C,EAGX,OAAOD,EAAQnC,MACjB,C,SASgBuC,EACd3B,KACGuB,GAEH,MAAMK,EAAqCX,EAAYM,EAAQnC,OAAS,GACxE,IAAK,MAAMO,KAASK,EAAQ,CAC1B,MAAM6B,EAASP,EAAmB3B,EAAO4B,GACzCK,EAAaC,GAAQ/B,KAAKH,E,CAE5B,OAAOiC,CACT,Q"}