{"version":3,"names":["RIPPLE","getAnimationDurationInMilliseconds","radiusPixels","Math","cbrt","setPositionRelativeIfStatic","element","getComputedStyle","position","classList","add","createRipple","event","options","button","_a","parent","currentTarget","existingRipple","getElementsByClassName","remove","Array","from","children","forEach","ripple","document","createElement","style","backgroundColor","color","setAttribute","diameter","max","clientWidth","clientHeight","radius","animationDuration","top","left","getBoundingClientRect","width","height","clientX","clientY","setProperty","prepend","cleanupAnimationOnFinish","async","listenOnce","setTimeout"],"sources":["src/utils/ripple.ts"],"sourcesContent":["import {listenOnce} from './event-utils';\r\n\r\ninterface RippleOptions {\r\n  color: string;\r\n  /**\r\n   * When the ripple's parent is not the event's origin\r\n   */\r\n  parent?: Element;\r\n}\r\n\r\nconst RIPPLE = 'ripple';\r\n\r\nfunction getAnimationDurationInMilliseconds(radiusPixels: number) {\r\n  // A 318px wide button has a duration of 700ms.\r\n  return Math.cbrt(radiusPixels) * 129.21;\r\n}\r\n\r\nfunction setPositionRelativeIfStatic(element: Element) {\r\n  if (getComputedStyle(element).position === 'static') {\r\n    element.classList.add('ripple-relative');\r\n  }\r\n}\r\n\r\nexport function createRipple(event: MouseEvent, options: RippleOptions) {\r\n  const button = options.parent ?? (event.currentTarget as Element);\r\n  const existingRipple = button.getElementsByClassName(RIPPLE)[0];\r\n  existingRipple && existingRipple.remove();\r\n\r\n  button.classList.add('ripple-parent');\r\n  setPositionRelativeIfStatic(button);\r\n  Array.from(button.children).forEach(setPositionRelativeIfStatic);\r\n\r\n  const ripple = document.createElement('span');\r\n  ripple.classList.add(RIPPLE);\r\n  ripple.style.backgroundColor = `var(--atomic-${options.color})`;\r\n  ripple.setAttribute('part', RIPPLE);\r\n\r\n  const diameter = Math.max(button.clientWidth, button.clientHeight);\r\n  const radius = diameter / 2;\r\n  const animationDuration = getAnimationDurationInMilliseconds(radius);\r\n  const {top, left} = button.getBoundingClientRect();\r\n  ripple.style.width = ripple.style.height = `${diameter}px`;\r\n  ripple.style.left = `${event.clientX - (left + radius)}px`;\r\n  ripple.style.top = `${event.clientY - (top + radius)}px`;\r\n  ripple.style.setProperty('--animation-duration', `${animationDuration}ms`);\r\n  button.prepend(ripple);\r\n  cleanupAnimationOnFinish(ripple, animationDuration);\r\n}\r\n\r\nasync function cleanupAnimationOnFinish(\r\n  ripple: HTMLSpanElement,\r\n  animationDuration: number\r\n) {\r\n  listenOnce(ripple, 'animationend', () => {\r\n    ripple && ripple.remove();\r\n  });\r\n  // Backup in case the button gets hidden or unmounted and the ripple hasn't been cleaned up.\r\n  setTimeout(\r\n    () => ripple?.remove(),\r\n    animationDuration + animationDuration * 0.1\r\n  );\r\n}\r\n"],"mappings":"oCAUA,MAAMA,EAAS,SAEf,SAASC,EAAmCC,GAE1C,OAAOC,KAAKC,KAAKF,GAAgB,MACnC,CAEA,SAASG,EAA4BC,GACnC,GAAIC,iBAAiBD,GAASE,WAAa,SAAU,CACnDF,EAAQG,UAAUC,IAAI,kB,CAE1B,C,SAEgBC,EAAaC,EAAmBC,G,MAC9C,MAAMC,GAASC,EAAAF,EAAQG,UAAM,MAAAD,SAAA,EAAAA,EAAKH,EAAMK,cACxC,MAAMC,EAAiBJ,EAAOK,uBAAuBnB,GAAQ,GAC7DkB,GAAkBA,EAAeE,SAEjCN,EAAOL,UAAUC,IAAI,iBACrBL,EAA4BS,GAC5BO,MAAMC,KAAKR,EAAOS,UAAUC,QAAQnB,GAEpC,MAAMoB,EAASC,SAASC,cAAc,QACtCF,EAAOhB,UAAUC,IAAIV,GACrByB,EAAOG,MAAMC,gBAAkB,gBAAgBhB,EAAQiB,SACvDL,EAAOM,aAAa,OAAQ/B,GAE5B,MAAMgC,EAAW7B,KAAK8B,IAAInB,EAAOoB,YAAapB,EAAOqB,cACrD,MAAMC,EAASJ,EAAW,EAC1B,MAAMK,EAAoBpC,EAAmCmC,GAC7D,MAAME,IAACA,EAAGC,KAAEA,GAAQzB,EAAO0B,wBAC3Bf,EAAOG,MAAMa,MAAQhB,EAAOG,MAAMc,OAAS,GAAGV,MAC9CP,EAAOG,MAAMW,KAAO,GAAG3B,EAAM+B,SAAWJ,EAAOH,OAC/CX,EAAOG,MAAMU,IAAM,GAAG1B,EAAMgC,SAAWN,EAAMF,OAC7CX,EAAOG,MAAMiB,YAAY,uBAAwB,GAAGR,OACpDvB,EAAOgC,QAAQrB,GACfsB,EAAyBtB,EAAQY,EACnC,CAEAW,eAAeD,EACbtB,EACAY,GAEAY,EAAWxB,EAAQ,gBAAgB,KACjCA,GAAUA,EAAOL,QAAQ,IAG3B8B,YACE,IAAMzB,IAAM,MAANA,SAAM,SAANA,EAAQL,UACdiB,EAAoBA,EAAoB,GAE5C,Q"}